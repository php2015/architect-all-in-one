{"version":3,"file":"vue.js","sources":["../src/utils.js","../src/global-api/index.js","../src/compiler/generate.js","../src/compiler/parse.js","../src/compiler/index.js","../src/vdom/patch.js","../src/observer/dep.js","../src/observer/scheduler.js","../src/observer/watcher.js","../src/lifecycle.js","../src/observer/array.js","../src/observer/index.js","../src/state.js","../src/init.js","../src/vdom/index.js","../src/render.js","../src/index.js"],"sourcesContent":["export function proxy(vm, data, key) {\n  Object.defineProperty(vm, key, {\n    get() {\n      return vm[data][key] // vm._data.a\n    },\n    set(newVal) {\n      // 触发set的时候，会得到这个值\n      vm[data][key] = newVal // vm._data.a = 100;\n    },\n  })\n}\n\nexport function isFunction(val) {\n  return typeof val === \"function\"\n}\n\nexport function isObject(val) {\n  return typeof val === \"object\" && val !== null\n}\n\n// 用一个全局的callbacks 接收用户传递进来的更新回调\nconst callbacks = []\nlet waiting = false\n// 用一个方法依次执行这些回调\nfunction flushCallbacks() {\n  callbacks.forEach((cb) => cb())\n  waiting = false\n}\n\nfunction timer(flushCallbacks) {\n  let timerFn = () => {}\n  if (Promise) {\n    timerFn = () => {\n      Promise.resolve().then(flushCallbacks)\n    }\n  } else if (MutationObserver) {\n    let textNode = document.createTextNode(1)\n    let observe = new MutationObserver(flushCallbacks)\n\n    observe.observe(textNode, {\n      characterData: true,\n    })\n\n    timerFn = () => {\n      textNode.textContent = 3\n    }\n  } else if (setImmediate) {\n    timerFn = () => {\n      setImmediate(flushCallbacks)\n    }\n  } else {\n    timerFn = () => {\n      setTimeout(flushCallbacks)\n    }\n  }\n  timerFn()\n}\n\n// vue2中考虑了兼容性的问题 vue3中不再考虑兼容性问题\nexport function nextTick(cb) {\n  callbacks.push(cb)\n  if (!waiting) {\n    setTimeout(() => {\n      timer(flushCallbacks)\n    }, 0)\n    waiting = true\n  }\n}\n\nlet lifeCycleHooks = [\n  \"beforeCreate\",\n  \"created\",\n  \"beforeMount\",\n  \"mounted\",\n  // ... 其他生命周期\n]\n\n// 策略对象\nlet strategy = {}\n\n/**\n * 这个函数是策略函数\n * @param {*} parentVal\n * @param {*} childVal\n */\n/**\n * 第一次： this.options:        {}              options: {beforeCreate: Fn}  =>  {beforeCreate: [fn]}\n * 第二次： this.options: {beforeCreate: [fn]}   options: {beforeCreate: Fn}  =>  {beforeCreate: [fn,fn]}\n */\nfunction mergeHook(parentVal, childVal) {\n  if (childVal) {  // 如果儿子有值 \n    if(parentVal) { // 父亲也有值\n      // 这里纠正一个误区,  \n      return parentVal.concat(childVal)\n    } else { // 父亲没有 将儿子拼装成一个数组\n      return [childVal]\n    }\n  } else { // 如果对应的属性 儿子没有只有父亲有 那直接返回父亲的\n    return parentVal\n  }\n}\n\nlifeCycleHooks.forEach((hook) => {\n  strategy[hook] = mergeHook\n})\n\nstrategy.components = function(parentVal, childVal) {\n  // console.log(parentVal) // 这里打印的是 undefined\n  // 根据父对象构造一个新的对象\n  let options = Object.create(parentVal||{});\n  if(childVal) {\n    for(let key in childVal) {\n      options[key] = childVal[key]\n    }\n  }\n  return options;\n}\n\n/**\n * 第一次： this.options:        {}              options: {beforeCreate: Fn}  =>  {beforeCreate: [fn]}\n * 第二次： this.options: {beforeCreate: [fn]}   options: {beforeCreate: Fn}  =>  {beforeCreate: [fn,fn]}\n */\nexport function mergeOptions(parent, child) {\n  // 合并之后的结果\n  const options = {}\n  // 以父对象为准，循环遍历\n  for (let key in parent) {\n    mergeFileld(key)\n  }\n  // 循环完毕 父亲之后 以儿子为基准 循环\n  for (let key in child) {\n    // 如果父亲中也有这个key 不需要重复合并\n    if (parent.hasOwnProperty(key)) {\n      // 继续下一个key的遍历\n      continue\n    }\n    mergeFileld(key)\n  }\n\n  function mergeFileld(key) {\n    let parentVal = parent[key]\n    let childVal = child[key]\n    if (strategy[key]) {\n      options[key] = strategy[key](parentVal, childVal)\n    } else {\n      // {a:1,data:{}} {data:{}} 类似于这种场景 我们需要判断\n      // 父亲key 对应的对象和 孩子key 对应的对象 如果都是对象\n      // 在大的option上面开辟一个key 合并这个两个\n      if (isObject(parentVal) && isObject(childVal)) {\n        options[key] = { ...parentVal, ...childVal }\n      } else {\n        // 其中有一个为对象，或者两个都不为对象\n        options[key] = child[key] || parent[key]\n      }\n    }\n  }\n  return options\n}\n\n/**\n * \n * @returns \n */\nexport function isReservedTag(str) {\n  return function() {\n    let reservedTag = 'a,span,div,p,img,button,ul,li';\n    console.log(reservedTag.includes(str));\n    return reservedTag.includes(str);\n  }\n}","import { mergeOptions } from \"../utils\"\n\nexport function initGlobalApi(Vue) {\n  Vue.options = {} // 用来存放全局的配置,每一个组件初始化的时候都会和options选项进行合并\n  // vue.component\n  // vue.filter\n  // vue.directive\n  Vue.mixin = function (options) {\n    // 将用户通过mixin 传递进来的选项和 全局的配置做合并\n    // 这里的this指的就是vue 后期可能是子组件\n    this.options = mergeOptions(this.options, options)\n    return this // 方面链式调用\n  }\n\n  Vue.options._base = Vue // 无论后续创建多少个子类 都可以通过_base 找到Vue\n  Vue.options.conponents = {}\n\n\n  /**\n   * 我们在自定义全局组件的时候，会使用这个api进行声明\n   */\n  Vue.component = function (id, definition) {\n    // 为了保证父子关系，我需要产生一个新的实例，这样做的目的是使得组件能够隔离，每个组件都会产生一个新的类, 去继承父类。\n    definition = this.options._base.extend(definition)\n    // 处理过之后 definition 就是一个类 这里做一个组件的映射表\n    this.options.conponents[id] = definition\n\n    console.log(this.options.conponents);\n  }\n  /**\n   * 其实就是返回一个类\n   * extend 方法就死产生一个继承与Vue的类\n   * 并且身上有父类的功能\n   */\n  Vue.extend = function (opts) {\n    const Super = this\n    // Sub 是一个函数\n    const Sub = function VueComponent() {\n      this._init()\n    }\n    Sub.prototype = Object.create(Super.prototype)\n    Sub.prototype.constructor = Sub // 原型继承\n    // 只和vue的options合并\n    Sub.options = mergeOptions(Super.options, opts)\n    return Sub\n  }\n}\n","// _c 类似于react中的 createElement \n// _v 创建虚拟节点\n// _s 可以看成是json.stringify();\n// render() {\n//   return _c('div', \n//              { \n//                id: 'app', \n//                style: { color: 'red' } \n//              }, \n//          _v( 'hello' + _s(name)), _c('span',null, _v('hello'))\n//          )\n// }\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; // 匹配双大括号\n// 生成属性方法 比如说 div中包含 {style: {}} \n/**\n * 这个attrs 中就是一个数组\n * @param {*} attrs \n */\nfunction genProps(attrs) {\n  // [\n  //   {name: \"id\", value: \"app\"},\n  //   {name: \"style\", value: \"color: red\"}\n  // ]\n  // console.log(JSON.stringify(attrs)) \n  // [{\"name\":\"id\",\"value\":\"app\"},{\"name\":\"style\",\"value\":\"font-size: 16px; background: yellowgreen;\"}]\n  let str = '';\n  for (let i = 0; i < attrs.length; i++) {\n\n    let attr = attrs[i];\n    // 对于style标签做特殊处理\n    if (attr.name === 'style') {\n      let obj = {};\n      // attr.value 是一个字符串 \"font-size: 16px; background: yellowgreen;\"}\n      // 先用 ; 分割成了 一个数组\n      // [\"font-size: 16px\", \"background: yellowgreen\",\"\"]\n      attr.value.split(';').forEach(item => {\n        // 数组解构的方式\n        if (item !== \"\") { // 如果最后一个属性后面有分号 数组的最后一项就会有一个 空 ”“\n          let [key, value] = item.split(':')\n          obj[key] = value;\n        }\n      });\n      attr.value = obj;\n      // console.log(attr.value) // {font-size: \" 16px\", \" background\": \" yellowgreen\"\n    }\n    str += `${attr.name}:${JSON.stringify(attr.value)},`;\n    // console.log(str) // generate.js:47 id:\"app\",style:{\"font-size\":\" 16px\",\" background\":\" yellowgreen\"},\n  }\n  // slice 方法可以提取字符串的某一个部分，并以新的字符串返回被提取的部分\n  // stringObject.slice(start,stop)\n  // start 开始位置，从某一个位置开始 \n  // stop 结束位置  如果是负数, 意思是从倒着数 返回start 和 stop 中间的部分\n  // 如果stop 不写，则返回的是从start 到结束的部分\n  return `{${str.slice(0, -1)}}`;\n}\n\nfunction gen(node) {\n  if (node.type == 1) {\n    return generate(node)\n  } else { // 如果是文本 \n    let text = node.text; // 获取文本\n    // 如果是普通文本\n    if (!defaultTagRE.test(text)) { // 如果文本中不包含{{}}\n      return `_v(${JSON.stringify(text)})`\n    }\n    let tokens = []; // 存放每一段代码\n    let lastIndex = defaultTagRE.lastIndex = 0; // 如果正则是全局模式，需要每次使用前值为0\n    let match, index; // 每次匹配到的结果\n    while (match = defaultTagRE.exec(text)) {\n      index = match.index;\n      if (index > lastIndex) {\n        tokens.push(JSON.stringify(text.slice(lastIndex, index)))\n      }\n      tokens.push(`_s(${match[1].trim()})`);\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) { // 后面还有一点没完事\n      tokens.push(JSON.stringify(text.slice(lastIndex)));\n    }\n\n    return `_v(${tokens.join('+')})`;\n  }\n}\n\nfunction genChildren(el) {\n  const children = el.children\n  if (children) {\n    return children.map(child => gen(child)).join(',') // 将所有转化后的儿子用逗号拼接起来)\n  }\n}\n\n// 语法层面的转义 将dom结构变成js的语法\n// 看一下元素里面有没有属性 如果有属性就生成属性。\nexport function generate(el) {\n  let children = genChildren(el)\n  // 这里面 el.tag 就是div 这里在写的时候需要特别注意,很容易写错\n  let code = `_c('${el.tag}',${el.attrs.length ? `${genProps(el.attrs)}` : 'undefined'}${children ? `,${genChildren(el)}` : ''})`;\n  return code;\n}","// 解析函数 如何解析这种标签\n{/* <div>hello <span>world</span></div> */ }\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*` // 这个这则匹配的是标签名称 <aa-aa></aa-aa> 类似于这样的东西\nconst qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\"; // 用来获取标签名称\nconst startTagOpen = new RegExp((\"^<\" + qnameCapture)); // 标签开头的正则表达式\nconst endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\")); // y用来匹配闭合标签的\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nconst startTagClose = /^\\s*(\\/?)>/;\n\n// 这里为什么要使用while循环呢,解析完一段就删除，直到字符串为空说明解析完毕\nexport function parseHTML(html) {\n  // 创建AST语法树\n  function createASTElement(tagName, attrs) {\n    return {\n      tag: tagName, // 标签名称\n      type: 1, // 元素类型\n      children: [], // 孩子列表\n      attrs, // 属性集合\n      parent: null // 父元素\n    }\n  }\n  // 根标签\n  let root;\n  // 处理开始标签 接收两个参数 一个是标签名称，一个是属性。\n  let currentParent; // 标识当前的父节点\n  let stack = [];\n\n  /**\n   * 开始标签 标签名称 和属性\n   * @param {*} tagName \n   * @param {*} attrs \n   */\n  function start(tagName, attrs) {\n    // console.log(tagName, attrs, '————————— 开始标签 —————————');\n    // 创建一个元素\n    let element = createASTElement(tagName, attrs);\n    if (!root) { // 如果没有根元素，这个创建的元素就是根元素。\n      root = element;\n    }\n    // 当前解析的标签 保存起来\n    currentParent = element;\n    // 开头的标签名称 放进栈中\n    stack.push(element);\n  }\n\n  // 处理结束标签\n  function end(tagName) { // 在标签闭合出创建父子关系\n    // 结束的时候将最后一个标签取出来\n    let element = stack.pop();\n    // pop 会改变原数组的长度。\n    // 然后取出数组的最后一个当做当前的 父元素\n    currentParent = stack[stack.length - 1];\n\n    if (currentParent) { // 标签闭合的时候可以知道这个标签的父亲\n      element.parent = currentParent;\n      currentParent.children.push(element);\n    };\n\n  }\n\n  // 处理文本\n  function chars(text) {\n    // console.log(text, '————————— 文本标签 —————————');\n    text = text.replace(/\\s/g, ''); //用正则 将文本标签中的空格去掉\n    if (text) { // 去掉空格之后 如果文本还存在\n      currentParent.children.push({\n        type: 3, // 文本类型\n        text\n      })\n    }\n  }\n\n  // 前进方法, 将匹配到的字符串删除掉，继续匹配后面的内容\n  // 这个substring方法：用于提取字符串中介于两个指定下标之间的字符\n  // stringObject.substring(start, stop)\n  // start 这个参数是必须的 一个非负的整数 规定要提取的的子串的第一个字符在stringObject中的位置\n  // stop 比要提取的子串的最后一个字符在stringObject中的位置多1 通俗来说 这是包头不包尾\n  function advance(n) {\n    // 将截取出来的字符串重新赋值给html\n    html = html.substring(n);\n  }\n  // 匹配开始标签\n  function parseStartTag() {\n    // 字符串的match方法可以在字符串内部检索指定的值，或者找到一个或者多个正则表达式的匹配\n    // 这个方法类似于 indexOf 但是它返回固定的值，而不是字符串的位置\n    // stringObject.match(searchValue)\n    // stringObject.match(regexp)\n    // 返回值是存放匹配结果的数组 该数组的内容依赖于 regexp 是否具有全局标志 g\n    const start = html.match(startTagOpen);\n    if (start) { // 匹配到的数组不为空\n      // 创建一个对象\n      const match = {\n        tagName: start[1],\n        attrs: [],\n      }\n      // 传入的这个是 <div 的长度删除开始标签\n      advance(start[0].length);\n      // console.log(html);\n      // 开始匹配属性，这个属性可能有多个，所以这里使用while循环\n      // 循环的条件是 不是闭合标签标签，且属性还没有匹配完毕\n      // 这种写法还是第一次看见\n      let end;\n      let attr;\n      // startTagClose 匹配的是闭合标签 attr 匹配的是属性\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        // 根据正则匹配的规则能够将 属性进行分组\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || attr[4] || attr[5]\n        })\n        // 匹配完毕属性之后继续前进，前进多少呢，当前匹配字符串的第0个的length;\n        advance(attr[0].length);\n        // console.log(html);\n      }\n      // 循环完毕属性之后 还会有一个结束标签 我们也要将结束标签去掉\n      if (end) { // >\n        // 如果哦结束标签存在的话,将结束标签也去掉。\n        advance(end[0].length);\n        // match 是一个对象\n        return match // 将 match的结果返回出去,开头的标签匹配宣告结束。\n      }\n    }\n  }\n\n\n  while (html) { // 只要html不为空字符串就一直解析\n    // 首先看看标签是不是以尖角号开头的\n    let textend = html.indexOf('<');\n    // 使用 字符串的indexOf方法 判断如果是0 说明确实是 以 <开头的 肯定是个开头标签\n    if (textend === 0) { \n      // 肯定是标签之后，就开始匹配开始标签\n      const startTagMatch = parseStartTag(); // 这就是开始标签匹配的结果\n      if (startTagMatch) { // 这里需要严谨一些 返回的是一个对象肯定是true\n        start(startTagMatch.tagName, startTagMatch.attrs);\n        // 匹配完开始标签 需要进行下一轮的匹配\n        continue;\n      };\n\n      // 开始匹配结束标签\n      const endTagMatch = html.match(endTag);\n      if (endTagMatch) {\n        // 同样的匹配到的标签删除掉。\n        advance(endTagMatch[0].length)\n        end(endTagMatch[1]);\n        // 结束标签匹配完成就执行下一轮的匹配。\n        continue\n      }\n    }\n    // 如果在下一个 < 的索引是大于0 的说明 第一个 开始标签匹配完之后到第二个开始标签\n    // 中间的部分是有文本的。\n    let text;\n    if (textend > 0) {\n      // substring 这个api的特点是不是包含头部而不包含尾部呢 这个需要确认一下。\n      text = html.substring(0, textend); \n    }\n    // 如果text 存在说明解析到了文本\n    if (text) {\n      advance(text.length); // 继续截取 html \n      chars(text)\n      // console.log(html); // <div id=\"my\">hello {{name}}<span>world</span></div></div>\n    }\n  }\n  // 将这个树返回出去\n  return root;\n}","import { generate } from \"./generate\";\nimport { parseHTML } from \"./parse\";\n\n/**\n * 编译函数 接收一个字符串\n * @param {*} template string\n */\nexport function complileToFunction(template) {\n  // => 将 html字符串变成render函数呢？\n\n  // 1、需要将 html 代码转换成 “ast” 语法树。可以用ast来描述语言本身\n  // const a = 1; 如何用ast来描述这一句话呢\n  // {\n  //   indentifier: const 使用const声明\n  //   name: a\n  //   value: 1\n  // }\n  // 这里需要有一个区分：虚拟dom 是用来描述节点的 而ast可以用来描述语言本身\n  // 前端需要掌握的数据结构 （树）\n  let ast = parseHTML(template); // 将template 转化成ast语法树\n  // 2、通过这颗树 重新生成代码。\n  // console.log(ast);\n  // 3、通过这颗树, 重新生成代码\n  let code = generate(ast);\n  // _c 类似于react中的 createElement \n  // _v 创建文本节点\n  // _s 可以看成是json.stringify();\n  // render() {\n  //   return _c('div', \n  //              { \n  //                id: 'app', \n  //                style: { color: 'red' } \n  //              }, \n  //          _v( 'hello' + _s(name)), _c('span',null, _v('hello'))\n  //          )\n  // }\n  // console.log(code);\n  // 4、将字符串变成函数\n  let render = new Function(`with(this){return ${code}}`)\n  return render\n}","export function createEle(vnode) {\n  let { tag, children, key, data, text, vm } = vnode\n  if (typeof tag === \"string\") {\n    // 创建元素放在vnode.el 上\n    vnode.el = document.createElement(tag)\n\n    // 创建元素完毕之后, 给元素添加属性 第一次渲染时候添加的属性\n    patchProps(vnode)\n\n    children.forEach((child) => {\n      // 遍历儿子，将儿子的渲染结果放进父亲中\n      vnode.el.appendChild(createEle(child))\n    })\n  } else {\n    // 创建文本\n    vnode.el = document.createTextNode(text)\n  }\n  return vnode.el\n}\n\nexport function patch(oldVnode, vnode) {\n  if (oldVnode.nodeType == 1) {\n    // 第一次渲染的时候 oldVode 传递的是$el\n\n    // 说明是真实的元素\n    // console.log('真实元素');\n    // 用vnode来生成真实的dom，替换虚拟dom\n\n    // 1、首先找到当前dom元素的父元素\n    let parentElment = oldVnode.parentNode\n    // console.log(parentElment)\n\n    // 2、根据虚拟节点创建元素\n    let ele = createEle(vnode)\n\n    // 3、将当前根据虚拟节点创建的元素插入到老元素的后面\n    parentElment.insertBefore(ele, oldVnode.nextSibling)\n\n    // 4、删除老的节点 打完收工\n    parentElment.removeChild(oldVnode)\n    // 将新创建的节点返回出去。\n    return ele\n  } else {\n    // 新旧节点的比较\n    // console.log(oldVnode,vnode)\n    // 如果标签名称不一样，直接删除掉老的换成新的节点\n    if (oldVnode.tag !== vnode.tag) {\n      // 我们之前在创建真实节点的时候, vnode.el = document.createElement(tag)\n      // 因此能够找到现在真实dom元素\n      return oldVnode.el.parentNode.replaceChild(createEle(vnode), oldVnode.el)\n      // console.log(oldVnode.el.parentNode)\n    }\n\n    let el = (vnode.el = oldVnode.el) // 当前新的节点还没有渲染，先复用老节点\n\n    // 如果两个虚拟节点是文本节点 比较文本内容。。。\n    if (vnode.tag == undefined) {\n      if (oldVnode.text !== vnode.text) {\n        el.textContent = vnode.text\n      }\n    }\n\n    // console.log(oldVnode.data)\n    // console.log(vnode)\n    // 生成新旧节点 如果标签一样，比较属性\n    // 传入新的虚拟节点和老的属性，用新的属性更新老的\n    patchProps(vnode, oldVnode.data)\n\n    // 一方有儿子 一方没有儿子\n    let oldChildren = oldVnode.children || []\n    let newChildren = vnode.children || []\n\n    console.log(oldChildren)\n    console.log(newChildren)\n\n    if (oldChildren.length > 0 && newChildren.length > 0) {\n      // 双方都有儿子 这块逻辑是最复杂的\n    } else if (newChildren.length > 0) {\n      // 老的没有儿子 但是新的有儿子\n      // 循环创建子元素并渲染\n      for (let i = 0; i < newChildren.length; i++) {\n        let child = createEle(newChildren[i]) // child 是虚拟节点\n        el.appendChild(child)\n      }\n    } else if (oldChildren.length > 0) {\n      // 老的有儿子 新的没有儿子\n      el.innerHTML = `` // 直接删除所有儿子\n    }\n  }\n}\n\n/**\n *\n * @param {*} vnode 新的虚拟节点\n * @param {*} oldProps 老的属性\n */\nfunction patchProps(vnode, oldProps = {}) {\n  let newProps = vnode.data || {}\n  let el = vnode.el\n  // console.log(JSON.stringify(newProps, null, 2))\n  /**\n    {\n      \"style\": {\n        \"color\": \"red\"\n      },\n      \"a\": \"1\"\n    } \n  */\n  // 如果老的属性有，新的没有 ，例如老的节点中有一个 a=1 这个属性\n  // 新的节点中有一个 b=2 这个属性，就行该保留2 删除1 应该怎么做呢？\n  // 还有一种情况，style中属性数量不一样，一个多 一个少，这个怎么操作呢\n  let newStyle = newProps.style || {}\n  let oldStyle = oldProps.style || {}\n\n  for (let key in oldStyle) {\n    if (!newStyle[key]) {\n      el.style[key] = \"\"\n    }\n  }\n\n  for (let key in oldProps) {\n    // 循环老的属性\n    if (!newProps[key]) {\n      // 如果新的属性中不存在\n      el.removeAttribute(key) // 删除这个属性 这个时候 操作的其实是真实的dom\n    }\n  }\n\n  // 这里属性有两种情况 一种是样式属性 style 一种是普通的属性\n  for (let key in newProps) {\n    // 需要针对style单独做样式处理\n    if (key === \"style\") {\n      // 对style 这个对象做循环\n      for (let styleName in newProps.style) {\n        // console.log(newProps.style[styleName])\n        el.style[styleName] = newProps.style[styleName]\n      }\n    } else {\n      el.setAttribute(key, newProps[key])\n    }\n  }\n}\n","/**\n * 每个属性我都给它分配一个dep dep可以存放watcher\n * 一个属性如果对应100个watcher (vuex中一个state可能在很多个页面中使用)\n * 同样的 watcher中可能存在多个属性, 因为每个属性都给他分配了一个dep 所以watcher中可能存在多个dep\n */\n\n// 为了保证dep的唯一性 也需要用一个id\nlet id = 0\nclass Dep {\n  constructor() {\n    this.id = id++\n    this.subs = [] // 用来存放watcher的\n  }\n  depend() {\n    // 走到这个函数的时候 dep.target 已经存在\n    if (Dep.target) {\n      // Dep.target 就是 watcher 这相当于\n      // watcher 上面有一个方法 addDep 把当前的 dep存进 watcher\n      // 这里还有一个场景 一个页面中多次使用一个变量，不需要重复的渲染，只渲染一次就好\n      Dep.target.addDep(this)\n    }\n  }\n  addSub(watcher) {\n    this.subs.push(watcher)\n  }\n  notify() {\n    this.subs.forEach((watcher) => watcher.update())\n  }\n}\n// 静态属性 全局的就这一份\nDep.target = null\n\nlet stack = [];\n\n// 提供出去的方法 将watcher 挂载到   Dep.target 属性上面\nexport function pushTarget(watcher) {\n  Dep.target = watcher\n  // 这种处理是为了解决，同一个dep（\b属性）记录多个watcher的过程。\n  stack.push(watcher)\n}\n\nexport function popTarget() {\n  // 渲染一次将当前的watcher 从栈中弹出\n  // 继续赋值另一个watcher\n  stack.pop();\n  Dep.target = stack[stack.length-1]\n}\n\nexport default Dep\n","import { nextTick } from \"../utils\"\n\nlet queue = []\nlet has = {} // 列表维护存放了哪些watcher\n\nfunction flushSchedulerQueue() {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i].run()\n  }\n  queue = []\n  has = {}\n  pending = true\n}\n\nlet pending = false\n// 当前执行栈中，代码执行完毕后，会先清空微任务，再清空宏任务\n// 希望尽早的执行一次更新操作\nexport function queueWatcher(watcher) {\n  const id = watcher.id\n\n  if (has[id] == null) {\n    queue.push(watcher)\n    has[id] = true\n    // 开启一次更新操作\n    if (!pending) {\n      nextTick(flushSchedulerQueue, 0)\n      pending = true\n    }\n  }\n}\n","import { popTarget, pushTarget } from \"./dep\"\nimport { queueWatcher } from \"./scheduler\"\n\nlet id = 0\n\nclass Watcher {\n  /**\n   * @param {*} vm\n   * @param {*} exprOrFn 表达式或者是个函数\n   * @param {*} cb\n   * @param {*} options\n   */\n  constructor(vm, exprOrFn, cb, options) {\n    this.vm = vm\n    // 这里做过备注，在渲染watcher中, exprOrFn 就是那个updateComponent\n    // 对于用户自己写的watcher 这里可能是个 字符串 或者表达式 需要手动处理\n    this.exprOrFn = exprOrFn\n    this.user = !!options.user // 标识是否是用户自己写的watcher\n    this.lazy = !!options.lazy // 是否立即执行get的标志位\n    // 这个dirty默认是脏的, 很巧妙的使用了 lazy的初始值\n    this.dirty = options.lazy\n    this.cb = cb\n    this.options = options\n    // 每 new 一次 watcher 这个id 就会累加\n    this.id = id++\n\n    // 这里需要对 exprOrFn 做一个判断\n    if (typeof exprOrFn == \"string\") {\n      // 将这个表达式转成一个函数 只要new Watcher的时候\n      this.getter = function () {\n        let path = exprOrFn.split(\".\") // [age,n] 分割成数组这种形式\n\n        let obj = vm\n        // 这里有点绕\n        for (let i = 0; i < path.length; i++) {\n          obj = obj[path[i]]\n        }\n        return obj\n      }\n    } else {\n      this.getter = exprOrFn\n    }\n    this.deps = []\n    // 每一个属性对应的是一个dep 这个我其实有点理解不了\n    this.depsId = new Set()\n    // new Watcher 的时候就会执行这个get方法\n    // 而这个get方法执行实际上就是我们传递进来 updateComponent 函数 执行\n    // 在用户自定义的watcher中 第一次调用get 方法就能拿到返回值\n    this.value = this.lazy ? undefined : this.get()\n  }\n  // 默认应该让exprOrFn执行 就是updateComponent这个方法 render 去vm上取值 每次取的都是新的值\n  get() {\n    // 在执行取值之前，先把这个watcher放进dep的target属性上\n    pushTarget(this)\n    // 每个属性都能收集自己的watcher\n    // 当我们执行 这个get方法的时候 会从defineProperty 执行get方法\n    // 每个属性都可以收集自己的watcher\n    // 每个组件都拥有一个渲染watcher 组件有100个属性，那这100个属性都是属于这一个渲染watcher的\n    // 对于vuex的使用场景来说，一个state 会在多个页面中用到，那这一个属性 对应的是多个 watcher\n    // 当这个state变化了，是需要通知多个watcher一起更新的\n\n    // 走到这个函数的时候 会从vm上取值，\b因为data上的属性已经被响应式了 会触发get方法\n    const value = this.getter.call(this.vm)\n\n    // 如果用户在模板外面取值，我们是不需要依赖收集的，此时清空\n    popTarget()\n\n    return value\n  }\n  update() {\n    // this.get()\n    // 对于多次修改属性的情况，我们只希望执行一次更新的操作，这种情况下\n    // 最好的就是对watcher做一个防抖的控制 限制它的更新频率\n    // 多次调用watcher 我希望缓存起来，等一下一起更新\n    // 所以说 vue中的更新操作是异步的\n    // 这里还需要加条件、关于计算属性的相关\n    if (this.lazy) {\n      // 说明是计算属性的watcher\n      this.dirty = true // 重新标识为脏值\n    } else {\n      queueWatcher(this)\n    }\n  }\n  run() {\n    let newValue = this.get()\n    let oldValue = this.value\n\n    this.value = newValue // 为了保证下一次的更新时，上一次的最新值是下一次的老值\n\n    if (this.user) {\n      this.cb.call(this.vm, newValue, oldValue)\n    }\n  }\n  addDep(dep) {\n    // 同一个属性在响应式的时候 有一个id属性\n    // 将这个id取出来\n    let id = dep.id\n    // 这里使用的set去重\n    if (!this.depsId.has(id)) {\n      // id 不存在 就将这个dep id 放进去\n      this.depsId.add(id)\n      // 然后将dep放进去  在页面中 可能使用多个属性 age name xxx\n      // 一个watcher 存放多个dep\n      this.deps.push(dep)\n      // 同样的 需要在dep中存放watcher （其实这里并不是很明白 为什么要让dep记住watcher ）\n      // 想想 vuex中的例子就知道了 dep 记录所有的 watcher\n      dep.addSub(this)\n    }\n  }\n  evaluate() {\n    this.dirty = false // 表示已经取过值了\n    this.value = this.get() // 这个就是用户的getter执行，把这个值返回\n  }\n  depend() {\n    let i = this.deps.length\n    while (i--) {\n      // 让lastname 和 firstname 收集渲染watcher\n      this.deps[i].depend(); \n    }\n  }\n}\n\nexport default Watcher\n","import { patch } from \"./vdom/patch\"\nimport Watcher from \"./observer/watcher\"\nimport { nextTick } from \"./utils\"\n\nexport function lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode) {\n    // 这个方法既在初始化的时候调用，也会在更新的情况下调用\n    const vm = this\n    vm.$el = patch(vm.$el, vnode)\n  }\n  // 用户自己调用的nextTick 也是这个方法\n  Vue.prototype.$nextTick = nextTick\n}\n\nexport function mountComponent(vm, el) {\n  // 更新函数 数据变化后，会再次调用这个函数\n  let updateComponent = () => {\n    // 在这个函数的内部核心只做了两件事情:\n    //    1、调用render方法生成虚拟dom\n    //    2、使用render方法渲染真实的dom\n    // 后续更新可以调用 updateComponent 这个方法\n    // 这里有一个细节需要注意, 在调用render的时候，会从vm上取值，必然触发 vm 上属性的get操作\n    vm._update(vm._render())\n  }\n  // 第一次渲染的时候先调用一次\n  // vue中视图更新是通过观察者模式实现的\n  // 属性:  被观察者  观察者:刷新页面\n  // 第一个参数是vm: 当前的实例\n  // 第二个参数是更新方法，也就是 updateComponent 这个方法\n  // 第三个参数是回调函数,就是更新完毕之后，需要执行的函数\n  // 第四个参数 是一个标识，代表的是渲染watcher\n  /**\n   * true 渲染watcher 说明还有其他 watcher\n   * 进行渲染的时候会创建一个watcher\n   * 有了watcher 之后 我们希望属性能和watcher有一个关联\n   */\n  new Watcher(\n    vm,\n    updateComponent,\n    () => {\n      console.log(\"我更新了\")\n    },\n    true\n  )\n}\n\n/**\n * 当生命周期的钩子已经收集完毕之后\n * 需要进行调用操作\n */\nexport function callHook(vm, hook) {\n  let handlers = vm.$options[hook]\n  if (handlers) {\n    for (let i = 0; i < handlers.length; i++) {\n      handlers[i].call(vm)\n    }\n  }\n}\n","let oldArrayPrototype = Array.prototype\n/**\n * 每一个构造函数都拥有一个prototype属性\n * 每一个对象被创建的时候都拥有原型对象\n * 每一个对象通过__proto__属性访问到自己的原型对象\n */\nexport let arrayMethods = Object.create(oldArrayPrototype)\n// arrayMethods.__proto__ = Array.prototype\n\n// 下面的这7个方法要记住呀，非常的重要呀\nlet methods = [\"push\", \"shift\", \"unshift\", \"pop\", \"reverse\", \"sort\", \"splice\"]\n\n// 下面这个写法非常重要，要注意了\nmethods.forEach((method) => {\n  // arrayMethods 是一个对象 对象的每一个方法都是一个函数\n  // 用户只要使用这7个方法，就会走到自己写的方法中。从而做到了数组劫持\n  // 你看：虽然看似是数组劫持，其实是考察原型链的继承\n  arrayMethods[method] = function (...args) {\n    // 用户传递进来的参数列表 arr.push(1,2,3) ...args = [1,2,3]\n    // 这里我之前一直不是很理解 其实这里 ...args 就是一个整体\n    // 这里的this指向的是谁？ 谁调用就是谁 我们最终会使用 vm.arr.push() pop() 那this就是 数组\n    // 这里数组没有监控索引的变化\n    oldArrayPrototype[method].call(this, ...args)\n\n    let inserted;\n    // 这部分有些绕，绕的地方主要是两个this指的是啥\n    // 这里的this 对应的是当前的数组 __ob__ 属性对应的是Observe实例\n    let ob = this.__ob__; // 这是一个自定义的属性 \n    // 对于数组的新增方法 需要做处理\n    switch (method) {\n      case 'push': // arr.push({a:1},{b:2})\n      case 'unshift': // 这两个方法 都是追加，追加的内容可能是对象类型 应该被再次进行劫持\n        inserted = args // 将args 赋值给这个需要插入的变量\n        break;\n      case 'splice': // vue.$set的原理\n        inserted = args.slice(2); // arr.splice(0,1,{a:1})\n      default:\n        break;\n    }\n\n    if (inserted) {\n      // 为了拿到observe 实例上面的 observeArray 方法 \n      // 先提前将 这个实例绑定到了数组上面\n      inserted = ob.observeArray(inserted); // 给数组新增的值也要进行观测\n    }\n    // 数组本身的watcher 更新\n    ob.dep.notify();\n  }\n})\n","import { isObject } from \"../utils\"\nimport { arrayMethods } from \"./array\"\nimport Dep from \"./dep\"\n\n\n\nfunction dependArray(value) {\n  for(let i = 0;i< value.length;i++) {\n    // 这个 current 是数组中的数组 \n    let current = value[i];\n    current.__ob__ && current.__ob__.dep.depend();\n\n    if(Array.isArray(current)) {\n      dependArray(current)\n    }\n  }\n}\n\n/**\n * vue2会对对象进行遍历，将每个属性 用defineProperty 重新定义 性能差\n * defineReactive 是一个包装 内部就是使用\n * @param {*} data\n * @param {*} key\n * @param {*} value\n */\nfunction defineReactive(data, key, value) {\n  /**\n   * 你看这很显然就是一个递归的操作，发现对象里面嵌套对象\n   * 还是可以进一步的做响应式的处理\n   */\n  let childOb =  observe(value)\n  // 这个value值也可能是一个数组，defineProperty 本身是不涉及value的\n  // 这个value 是通过 defineReactive 这个函数传递进来的\n  // 这个 defineReactive 每个属性都会执行, 在这里 创建一个dep\n  let dep = new Dep()\n  Object.defineProperty(data, key, {\n    // 取值的时候创建一个dep\n    get() {\n      // 渲染之前的时候先将watcher放在了dep.target上\n      // 然后将dep.target 置空 这样 在模板下面取值时候就不会依赖收集\n      if (Dep.target) {\n        dep.depend(); // 让dep记住watcher 这个是比较核心的逻辑\n        if (childOb) {\n          childOb.dep.depend();\n\n          // 对于数组中子元素还是数组的情况，还需要做依赖收集\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      // console.log(key)\n      return value\n    },\n    set(newV) {\n      /**\n       * 如果用户赋值一个新的对象 需要将这个对象进行劫持\n       */\n      if(newV !== value) {\n        observe(newV)\n        value = newV\n        // 告诉当前的属性存放的watcher执行\n        dep.notify()\n      }\n    },\n  })\n}\n\n// 如果我们给对象新增一个属性并不会触发视图更新，为了解决这个问题，我们可以给（对象本身也增加一个dep  dep存watcher） 如果\n// 增加一个属性后，我们就手动触发watcher的更新 这就是$set的实现原理。 \nclass Observer {\n  constructor(data) {\n\n    this.dep = new Dep();\n\n    // 这里使用defineProperty 定义一个 __ob__ 属性\n    // object.defineProperty 方法会直接在一个对象上定义一个新属性。\n    // 或者修改一个对象的现有属性，并返回此对象。判断一个对象是否被观测过，看它有没有 __ob__ 属性\n    // 注意 使用这个方法定义的属性是不会被枚举的到，不可枚举的好处是不会造成死循环，这里写的真的很好\n    Object.defineProperty(data, \"__ob__\", {\n      enumerable: false,\n      configurable: false,\n      value: this,\n    })\n\n    if (Array.isArray(data)) {\n      // 对于对象来说，我们可以给他的属性添加dep，那对于数组该如何处理呢\n\n\n      // 数组的处理 对数组原来的方法进行改写，这种思路就是面向切面编程\n      // 虽然在最后还是会调用数组原来的方法，但是会在外面包一层函数,\n      // 可以在包装的这层函数中加入自己的一些逻辑——高阶函数\n      // 在学习这部分的内容时候对于原型的理解终究是有些模糊，推荐一篇文章\n      // https://github.com/mqyqingfeng/Blog/issues/2\n      // 文章中有一句话说的特别清晰：每一个JavaScript对象 (null) 除外都拥有__proto__属性 指向它的原型对象\n      data.__proto__ = arrayMethods\n\n      // 这里还需要处理一种情况，如果数组中的元素还是数组，或者数组中的元素是对象，\n      // 我们原则上是需要支持观测内部对象变化的，虽然vue中对于数组没有监控索引的变化\n      // 但是针对数组中元素是对象的情况还是做了处理。\n      this.observeArray(data)\n    } else {\n      // 对象的处理\n      this.work(data)\n    }\n  }\n  /**\n   * 观测对象\n   * @param {*} data\n   */\n  observeArray(data) {\n    // 对数组的每一项进行观测。\n    data.forEach((item) => {\n      observe(item)\n    })\n  }\n  /**\n   * data 是一个对象 遍历对象使用object.keys\n   * 这个方法已经很常见了。返回的是一个数组 数组的所有元素\n   * 由这个对象的key组成\n   * 划重点是所有的属性做响应式，哈哈哈，这部分一直迷糊\n   * @param {*} data\n   */\n  work(data) {\n    // console.log(Object.keys(data))  [\"name\", \"showFlag\"]\n    // 这里使用object.keys不会遍历原型上的属性\n    Object.keys(data).forEach((key) => {\n      // 将对象中的每一个「属性」！！！都进行响应式处理\n      defineReactive(data, key, data[key])\n    })\n  }\n}\n\n/**\n * 这个函数接收的是 处理后的data了，还记得在initState中\n * 对data的处理吗，如果判断是函数，就拿到函数的执行结果\n * 并且使用call来绑定this指向防止迷路。\n * @param {*} data\n * @returns\n */\nexport function observe(data) {\n  // 响应式部分是针对对象来说的，如果不是对象直接略过\n  if (!isObject(data)) {\n    return\n  }\n\n  // 这里做一个判断，如果当前的这个数据已经被响应式了\n  // 直接返回就好，不需要重复响应式，最初添加这个属性是在Observer 这个类中做的\n  // 所以被观测的属性，都具有 __ob__ 属性  这个属性的值 还记得是什么吗 是那个 observer 实例\n  if (data.__ob__) {\n    return data.__ob__;\n  }\n\n  // 这里使用了一个类，之所以没有使用构造函数的原因是\n  // 功能比较耦合,返回的是一个实例\n  return new Observer(data)\n}\n","import { observe } from \"./observer/index.js\"\nimport { proxy } from \"./utils\"\nimport Watcher from \"./observer/watcher\"\nimport Dep from \"./observer/dep.js\"\n\nexport function stateMixin(Vue) {\n  /**\n   *\n   * @param {*} key\n   * @param {*} handler\n   * @param {*} options 可以接收用户传参立即调用\n   */\n  Vue.prototype.$watch = function (key, handler, options = {}) {\n    options.user = true // 标识是用户自己写的watcher\n    /**\n     * 原型上的方法  this指向当前实例\n     */\n    new Watcher(this, key, handler, options)\n  }\n}\n\n/**\n * 初始化数据处理函数 接收的参数是vm实例了\n * 因为很多组件的实例都是需要进行初始数据的\n * @param {*} vm\n */\nexport function initState(vm) {\n  // 还记得在 init.js 中将用户传递的 options 赋值给 vm.$options\n  // 这里可以直接取出来使用了\n  const opts = vm.$options\n  if (opts.props) {\n    initProps(vm)\n  }\n  if (opts.methods) {\n    initMethod(vm)\n  }\n  if (opts.data) {\n    // 初始化data\n    initData(vm)\n  }\n  if (opts.computed) {\n    initComputed(vm, opts.computed)\n  }\n  if (opts.watch) {\n    initWatch(vm, opts.watch)\n  }\n}\n/**\n * 这个函数专门用来处理用户传递进来的data\n * 我们写过vue的都知道，这个data中一般存放的都是页面\n * 中用于显示的响应式数据 比方说一些 tableList 还是一些展示标志位\n * @param {*} vm\n */\nfunction initData(vm) {\n  let data = vm.$options.data\n  // 这里使用 isFunction 工具函数判断传入的data是不是一个函数\n  // 如果是一个函数就执行这个函数，但是执行时候需要绑定vm,因为我们希望在整个执行的过程中\n  // this始终指向vm，也就是当前new出来的实例。\n  // 使用_data 和 data 做一个关联 两者使用同一份引用地址\n  vm._data = data = typeof data === \"function\" ? data.call(vm) : data\n\n  for (let key in data) {\n    proxy(vm, \"_data\", key)\n  }\n  // vue2中会将data中的所有数据 进行数据劫持 Object.defineProperty\n  observe(data)\n}\nfunction initProps() {}\nfunction initMethod() {}\n\n/**\n *\n * @param {*} vm\n * @param {*} computed\n */\nfunction initComputed(vm, computed) {\n  // 我希望做一个关联，将key 和watcher做一个关联\n  // 在vm 上面放置一个属性_computedWatchers 和 watchers 用的是同一个对象\n  const watchers = (vm._computedWatchers = {})\n\n  // 为什么这里需要循环，因为计算属性很多，我需要创建多个watcher\n  // computed 有两种写法 我平时习惯使用第一中 那种get 个 set的 不经常使用\n  for (let key in computed) {\n    // 首先传递参数的时候 也是以对象的形式传递进来的\n    // 用户定义的\n    const userDef = computed[key]\n\n    // 依赖的属性变化就是重新取值\n    // 这里做个简单的判断，如果是函数，那当前这个函数就是getter\n    // 如果是对象 对象的get 方法就是要的那个值\n    let getter = typeof userDef === \"function\" ? userDef : userDef.get\n\n    /**\n     * 感觉watcher 这个概念真的好难呀 有点理解不了\n     * computed 默认是不直接执行的 所以在options\n     * 选项中 lazy 设置为true 不要默认执行\n     * 将watcher 和属性做一个映射 相当于一个map\n     */\n    watchers[key] = new Watcher(vm, getter, () => {}, { lazy: true })\n\n    // 将key 定义在vm上\n    defineComputed(vm, key, userDef)\n  }\n}\n\n/**\n * 首先这个函数存在的意义是什么呢\n * 就是做一个缓存的功能，不要轻易触发getter方法\n * 这就是一个高阶函数\n */\nfunction createComputedGetter(key) {\n  // 取计算属性值的时候 走的是这个函数\n  // 只要createComputedGetter 函数执行\n  return function computedGetter() {\n    // 这里的this 指的就是vm  this._computedWatchers 包含\n    // 所有的计算属性 通过key 可以拿到对应的watcher wather 中包含对应的watcher\n    let watcher = this._computedWatchers[key]\n\n    // 看这个watcher是不是脏的 根据这个属性判断是否可以重新执行\n    // 脏就是调用用户的getter 不脏就是不用调用用户的getter\n    if (watcher.dirty) {\n      watcher.evaluate()\n    }\n\n    // 如果当前在取完值之后 Dep.target还有值 需要继续向上收集\n    if(Dep.target) { // 当前的Dep.target\n      // 让当前的计算属性也记录watcher \n      // 计算属性watcher 内部记录了两个dep firstname lastname 反向查找\n      watcher.depend();\n    }\n\n    return watcher.value\n  }\n}\n\n/**\n *\n * @param {*} vm\n * @param {*} key\n * @param {*} userDef\n */\nfunction defineComputed(vm, key, userDef) {\n  let sharedProperty = {}\n\n  if (typeof userDef === \"function\") {\n    sharedProperty.get = userDef\n  } else {\n    sharedProperty.get = createComputedGetter(key)\n    sharedProperty.set = userDef.set\n  }\n  // 本质上还是一个 Object.defineProperty\n  // 定义在vm 上的 属性key 传入的 get 和 set 做了处理\n  Object.defineProperty(vm, key, sharedProperty)\n}\n\n/**\n *\n * @param {*} vm\n * @param {*} watch\n */\nfunction initWatch(vm, watch) {\n  // watch 传入的是一个对象 这里需要循环一下，拿到每一个key\n\n  for (let key in watch) {\n    let handler = watch[key]\n\n    // 一个 属性可以接收多个回调函数，所以这里 handler 可能是个数组\n    if (Array.isArray(handler)) {\n      for (let i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i])\n      }\n    } else {\n      // 如果不是一个数组，那就是一个简单的函数\n      createWatcher(vm, key, handler)\n    }\n  }\n}\n\n/**\n * 创建watcher\n */\nfunction createWatcher(vm, key, handler) {\n  // 用户可能直接使用 vm.$watch 这种形式调用。\n  // 我们需要在原型上定义 $watch 方法\n  return vm.$watch(key, handler)\n}\n","import { complileToFunction } from \"./compiler/index.js\"\nimport { callHook, mountComponent } from \"./lifecycle.js\"\nimport { initState } from \"./state\"\nimport { mergeOptions } from \"./utils.js\"\n\n/**\n * 将构造函数作为参数传递进去，对构造函数进行扩展，\n * 这里使用了在构造函数的原型上进行扩展的方式，所有的组件实例均可以共享\n * 表示在vue的基础上做一次混合操作\n * 这种设计思想也是非常值得借鉴的。\n * @param {*} Vue\n */\nexport function initMixin(Vue) {\n  // 扩展原型上的方法\n  Vue.prototype._init = function (options) {\n    // 原型方法中的this指向实例 所有的实例都具有这些方法，\n    // 这里用vm表示this的引用比较方便识别。假设在这个函数中\n    // 直接有一个函数声明，函数声明中的this就不好说是谁了。\n    // 但是可以在函数中使用vm,这个就特别类似于 var that = this 那种写法\n    const vm = this\n    // 用户传递进来的options属性挂载到vm上面, 这时我们能够操作vm.$options\n    // 如果用户写了全局的mixin，这个时候需要将全局的mixin 和当前用户传递进来的options合并\n    vm.$options = mergeOptions(vm.constructor.options,options)\n    \n    // console.log(vm.$options)\n    \n    // 数据还没有创建的时候 调用\n    callHook(vm,'beforeCreate')\n    // 初始化状态 模板渲染的数据需要这个函数  不仅仅是有watch 还有computed props data 我们需要有一个统一的函数\n    // 来处理这些参数。用户也是将不同的状态放在不同的对象下面进行维护\n    initState(vm)\n    // 数据已经初始化完毕\n    callHook(vm,'created')\n\n    // 数据初始化就这样结束了吗？ 当然没有 我们还需要将数据挂载到模板上面\n    if (vm.$options.el) {\n      // 将数据挂载到模板上\n      vm.$mount(vm.$options.el)\n    }\n  }\n  /**\n   * 这个就是那个渲染的方法\n   * 我们说，如果每次数据变化，就全部将模板替换，这种方式是很低效的\n   * 因为vue2 中将模板转换成渲染函数，函数的执行效率要高很多。\n   * 并且引入了虚拟dom的概念，每次数据变化，生成虚拟节点。而不是真正的操作dom\n   * @param {*} el\n   */\n  Vue.prototype.$mount = function (el) {\n    const vm = this\n    const options = vm.$options\n    el = document.querySelector(el)\n    vm.$el = el\n    // 这里解释下为什么要做这个判断，因为会有情况是用户手动写render方法\n    // 这种情况下用户手写的render优先级要更高一些。这个函数的终极目标是帮助我们创建出虚拟节点\n    // 这部分信息量比较大，我们可以在options的选项中添加 template 字段\n    // 如果没写，才使用 html中写的dom节点，这点应该尤其注意\n    if (!options.render) {\n      let template = options.template\n      if (!template) {\n        template = el.outerHTML\n        // 下面这一行打印的是字符串\n        // console.log(template) <div id=\"app\">{{name}}</div>\n        // 这个函数是一个核心的函数，将我们传递进去的模板编译成 render函数\n        let render = complileToFunction(template)\n        options.render = render\n      }\n    }\n    // 调用render方法 渲染成真实的dom替换掉页面的内容\n    // 这个方法是定义在生命周期这个包中的\n    mountComponent(vm, el)\n  }\n}\n","import { isReservedTag } from \"../utils\"\n\n// 专门有一个包来处理虚拟节点\nexport function createElement(vm, tag, data = {}, ...children) {\n  // 这里我们应该对于原生标签和 组件做一个区分，最简单的就是区分出原生标签\n  // 剩下的就是组件标签\n  if(isReservedTag(tag)) {\n    return vnode(vm, tag, data, data.key, children, undefined)\n  } else {\n    console.log('组件的渲染')\n  }\n}\n\nexport function createTextElement(vm, text) {\n  return vnode(vm, undefined, undefined, undefined, undefined, text)\n}\n\nfunction vnode(vm, tag, data, key, children, text) {\n  return {\n    vm,\n    tag,\n    data,\n    key,\n    children,\n    text,\n  }\n}\n","import { createElement, createTextElement } from \"./vdom/index\"\n\nexport function renderMixin(Vue) {\n  Vue.prototype._c = function () {\n    // createElement\n    return createElement(this, ...arguments)\n  }\n  Vue.prototype._v = function (text) {\n    // createTextElement\n    return createTextElement(this, text)\n  }\n  Vue.prototype._s = function (val) {\n    if (typeof val === \"object\") {\n      return JSON.stringify(val)\n    }\n    return val\n  }\n  Vue.prototype._render = function () {\n    const vm = this\n    let render = vm.$options.render // 这个render 就是我们解析出来的render方法 同时也有可能是用户自己写的render\n\n    let vnode = render.call(vm)\n\n    return vnode\n  }\n}\n","import { initGlobalApi } from \"./global-api/index\"\nimport { initMixin } from \"./init\"\nimport { lifecycleMixin } from \"./lifecycle\"\nimport { renderMixin } from \"./render\"\nimport { stateMixin } from \"./state\"\n\n/**\n * 这里是一个函数声明，只有在new的时候才会调用\n * 接收一个 options 作为参数，options 是一个对象\n * 这个options就是用户传递进来的配置选项\n * 这个配置选项中包含 data el watch computed methods。。。\n * 一些列的参数，在使用vue-cli脚手架进行开发的时候\n * 都是单组件文件 每个组件本质上都是一个实例\n * @param {*} options\n */\nfunction Vue(options) {\n  // options 为用户传入的选项\n  this._init(options) // 初始化操作\n}\n\n// 只要加载了index.js 这个文件下面的函数都会执行\n// 并且是首先执行的，那么所有在mixin上挂载的所有原型\n// 方法都会预先定义执行，init 是在new 的时候执行的\ninitMixin(Vue)\nstateMixin(Vue)\nrenderMixin(Vue) // 存放的是 _render\nlifecycleMixin(Vue) // 存放的是 _update\ninitGlobalApi(Vue) // 初始化全局api\n\n// 在这里 手动使用生成两个dom\nimport { complileToFunction } from \"./compiler/index.js\"\nimport { createEle, patch } from \"./vdom/patch.js\"\n\nlet oldTemplate = `<div style=\"color:red;background:yellow\" a=\"1\"></div>`\nlet vm1 = new Vue({\n  data: {\n    message: \"hello world\",\n  },\n})\nconst render1 = complileToFunction(oldTemplate)\nconst oldVnode = render1.call(vm1)\n// console.log(createEle(oldVnode))\ndocument.body.appendChild(createEle(oldVnode))\n\nlet newTemplate = `<div style=\"color:blue\" b=\"2\">{{message}}</div>`\nlet vm2 = new Vue({\n  data: {\n    message: \"vue\",\n  },\n})\nconst render2 = complileToFunction(newTemplate)\nconst newVnode = render2.call(vm2)\n\n// 根据新的虚拟节点更新老的节点，老的能够复用尽量复用\nsetTimeout(() => {\n  patch(oldVnode, newVnode)\n}, 2000)\n\n// 将vue导出\nexport default Vue\n"],"names":["proxy","vm","data","key","Object","defineProperty","get","set","newVal","isObject","val","callbacks","waiting","flushCallbacks","forEach","cb","timer","timerFn","Promise","resolve","then","MutationObserver","textNode","document","createTextNode","observe","characterData","textContent","setImmediate","setTimeout","nextTick","push","lifeCycleHooks","strategy","mergeHook","parentVal","childVal","concat","hook","components","options","create","mergeOptions","parent","child","mergeFileld","hasOwnProperty","isReservedTag","str","reservedTag","console","log","includes","initGlobalApi","Vue","mixin","_base","conponents","component","id","definition","extend","opts","Super","Sub","VueComponent","_init","prototype","constructor","defaultTagRE","genProps","attrs","i","length","attr","name","obj","value","split","item","JSON","stringify","slice","gen","node","type","generate","text","test","tokens","lastIndex","match","index","exec","trim","join","genChildren","el","children","map","code","tag","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","createASTElement","tagName","root","currentParent","stack","start","element","end","pop","chars","replace","advance","n","substring","parseStartTag","textend","indexOf","startTagMatch","endTagMatch","complileToFunction","template","ast","render","Function","createEle","vnode","createElement","patchProps","appendChild","patch","oldVnode","nodeType","parentElment","parentNode","ele","insertBefore","nextSibling","removeChild","replaceChild","undefined","oldChildren","newChildren","innerHTML","oldProps","newProps","newStyle","style","oldStyle","removeAttribute","styleName","setAttribute","Dep","subs","target","addDep","watcher","update","pushTarget","popTarget","queue","has","flushSchedulerQueue","run","pending","queueWatcher","Watcher","exprOrFn","user","lazy","dirty","getter","path","deps","depsId","Set","call","newValue","oldValue","dep","add","addSub","depend","lifecycleMixin","_update","$el","$nextTick","mountComponent","updateComponent","_render","callHook","handlers","$options","oldArrayPrototype","Array","arrayMethods","methods","method","args","inserted","ob","__ob__","observeArray","notify","dependArray","current","isArray","defineReactive","childOb","newV","Observer","enumerable","configurable","__proto__","work","keys","stateMixin","$watch","handler","initState","props","initData","computed","initComputed","watch","initWatch","_data","watchers","_computedWatchers","userDef","defineComputed","createComputedGetter","computedGetter","evaluate","sharedProperty","createWatcher","initMixin","$mount","querySelector","outerHTML","createTextElement","renderMixin","_c","arguments","_v","_s","oldTemplate","vm1","message","render1","body","newTemplate","vm2","render2","newVnode"],"mappings":"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"}