{"version":3,"file":"vue.js","sources":["../src/compiler/generate.js","../src/compiler/parse.js","../src/compiler/index.js","../src/vdom/patch.js","../src/observer/dep.js","../src/utils.js","../src/observer/scheduler.js","../src/observer/watcher.js","../src/lifecycle.js","../src/observer/array.js","../src/observer/index.js","../src/state.js","../src/init.js","../src/vdom/index.js","../src/render.js","../src/index.js"],"sourcesContent":["// _c 类似于react中的 createElement \n// _v 创建虚拟节点\n// _s 可以看成是json.stringify();\n// render() {\n//   return _c('div', \n//              { \n//                id: 'app', \n//                style: { color: 'red' } \n//              }, \n//          _v( 'hello' + _s(name)), _c('span',null, _v('hello'))\n//          )\n// }\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; // 匹配双大括号\n// 生成属性方法 比如说 div中包含 {style: {}} \n/**\n * 这个attrs 中就是一个数组\n * @param {*} attrs \n */\nfunction genProps(attrs) {\n  // [\n  //   {name: \"id\", value: \"app\"},\n  //   {name: \"style\", value: \"color: red\"}\n  // ]\n  // console.log(JSON.stringify(attrs)) \n  // [{\"name\":\"id\",\"value\":\"app\"},{\"name\":\"style\",\"value\":\"font-size: 16px; background: yellowgreen;\"}]\n  let str = '';\n  for (let i = 0; i < attrs.length; i++) {\n\n    let attr = attrs[i];\n    // 对于style标签做特殊处理\n    if (attr.name === 'style') {\n      let obj = {};\n      // attr.value 是一个字符串 \"font-size: 16px; background: yellowgreen;\"}\n      // 先用 ; 分割成了 一个数组\n      // [\"font-size: 16px\", \"background: yellowgreen\",\"\"]\n      attr.value.split(';').forEach(item => {\n        // 数组解构的方式\n        if (item !== \"\") { // 如果最后一个属性后面有分号 数组的最后一项就会有一个 空 ”“\n          let [key, value] = item.split(':')\n          obj[key] = value;\n        }\n      });\n      attr.value = obj;\n      // console.log(attr.value) // {font-size: \" 16px\", \" background\": \" yellowgreen\"\n    }\n    str += `${attr.name}:${JSON.stringify(attr.value)},`;\n    // console.log(str) // generate.js:47 id:\"app\",style:{\"font-size\":\" 16px\",\" background\":\" yellowgreen\"},\n  }\n  // slice 方法可以提取字符串的某一个部分，并以新的字符串返回被提取的部分\n  // stringObject.slice(start,stop)\n  // start 开始位置，从某一个位置开始 \n  // stop 结束位置  如果是负数, 意思是从倒着数 返回start 和 stop 中间的部分\n  // 如果stop 不写，则返回的是从start 到结束的部分\n  return `{${str.slice(0, -1)}}`;\n}\n\nfunction gen(node) {\n  if (node.type == 1) {\n    return generate(node)\n  } else { // 如果是文本 \n    let text = node.text; // 获取文本\n    // 如果是普通文本\n    if (!defaultTagRE.test(text)) { // 如果文本中不包含{{}}\n      return `_v(${JSON.stringify(text)})`\n    }\n    let tokens = []; // 存放每一段代码\n    let lastIndex = defaultTagRE.lastIndex = 0; // 如果正则是全局模式，需要每次使用前值为0\n    let match, index; // 每次匹配到的结果\n    while (match = defaultTagRE.exec(text)) {\n      index = match.index;\n      if (index > lastIndex) {\n        tokens.push(JSON.stringify(text.slice(lastIndex, index)))\n      }\n      tokens.push(`_s(${match[1].trim()})`);\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) { // 后面还有一点没完事\n      tokens.push(JSON.stringify(text.slice(lastIndex)));\n    }\n\n    return `_v(${tokens.join('+')})`;\n  }\n}\n\nfunction genChildren(el) {\n  const children = el.children\n  if (children) {\n    return children.map(child => gen(child)).join(',') // 将所有转化后的儿子用逗号拼接起来)\n  }\n}\n\n// 语法层面的转义 将dom结构变成js的语法\n// 看一下元素里面有没有属性 如果有属性就生成属性。\nexport function generate(el) {\n  let children = genChildren(el)\n  // 这里面 el.tag 就是div 这里在写的时候需要特别注意,很容易写错\n  let code = `_c('${el.tag}',${el.attrs.length ? `${genProps(el.attrs)}` : 'undefined'}${children ? `,${genChildren(el)}` : ''})`;\n  return code;\n}","// 解析函数 如何解析这种标签\n{/* <div>hello <span>world</span></div> */ }\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*` // 这个这则匹配的是标签名称 <aa-aa></aa-aa> 类似于这样的东西\nconst qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\"; // 用来获取标签名称\nconst startTagOpen = new RegExp((\"^<\" + qnameCapture)); // 标签开头的正则表达式\nconst endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\")); // y用来匹配闭合标签的\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nconst startTagClose = /^\\s*(\\/?)>/;\n\n// 这里为什么要使用while循环呢,解析完一段就删除，直到字符串为空说明解析完毕\nexport function parseHTML(html) {\n  // 创建AST语法树\n  function createASTElement(tagName, attrs) {\n    return {\n      tag: tagName, // 标签名称\n      type: 1, // 元素类型\n      children: [], // 孩子列表\n      attrs, // 属性集合\n      parent: null // 父元素\n    }\n  }\n  // 根标签\n  let root;\n  // 处理开始标签 接收两个参数 一个是标签名称，一个是属性。\n  let currentParent; // 标识当前的父节点\n  let stack = [];\n\n  /**\n   * 开始标签 标签名称 和属性\n   * @param {*} tagName \n   * @param {*} attrs \n   */\n  function start(tagName, attrs) {\n    // console.log(tagName, attrs, '————————— 开始标签 —————————');\n    // 创建一个元素\n    let element = createASTElement(tagName, attrs);\n    if (!root) { // 如果没有根元素，这个创建的元素就是根元素。\n      root = element;\n    }\n    // 当前解析的标签 保存起来\n    currentParent = element;\n    // 开头的标签名称 放进栈中\n    stack.push(element);\n  }\n\n  // 处理结束标签\n  function end(tagName) { // 在标签闭合出创建父子关系\n    // 结束的时候将最后一个标签取出来\n    let element = stack.pop();\n    // pop 会改变原数组的长度。\n    // 然后取出数组的最后一个当做当前的 父元素\n    currentParent = stack[stack.length - 1];\n\n    if (currentParent) { // 标签闭合的时候可以知道这个标签的父亲\n      element.parent = currentParent;\n      currentParent.children.push(element);\n    };\n\n  }\n\n  // 处理文本\n  function chars(text) {\n    // console.log(text, '————————— 文本标签 —————————');\n    text = text.replace(/\\s/g, ''); //用正则 将文本标签中的空格去掉\n    if (text) { // 去掉空格之后 如果文本还存在\n      currentParent.children.push({\n        type: 3, // 文本类型\n        text\n      })\n    }\n  }\n\n  // 前进方法, 将匹配到的字符串删除掉，继续匹配后面的内容\n  // 这个substring方法：用于提取字符串中介于两个指定下标之间的字符\n  // stringObject.substring(start, stop)\n  // start 这个参数是必须的 一个非负的整数 规定要提取的的子串的第一个字符在stringObject中的位置\n  // stop 比要提取的子串的最后一个字符在stringObject中的位置多1 通俗来说 这是包头不包尾\n  function advance(n) {\n    // 将截取出来的字符串重新赋值给html\n    html = html.substring(n);\n  }\n  // 匹配开始标签\n  function parseStartTag() {\n    // 字符串的match方法可以在字符串内部检索指定的值，或者找到一个或者多个正则表达式的匹配\n    // 这个方法类似于 indexOf 但是它返回固定的值，而不是字符串的位置\n    // stringObject.match(searchValue)\n    // stringObject.match(regexp)\n    // 返回值是存放匹配结果的数组 该数组的内容依赖于 regexp 是否具有全局标志 g\n    const start = html.match(startTagOpen);\n    if (start) { // 匹配到的数组不为空\n      // 创建一个对象\n      const match = {\n        tagName: start[1],\n        attrs: [],\n      }\n      // 传入的这个是 <div 的长度删除开始标签\n      advance(start[0].length);\n      // console.log(html);\n      // 开始匹配属性，这个属性可能有多个，所以这里使用while循环\n      // 循环的条件是 不是闭合标签标签，且属性还没有匹配完毕\n      // 这种写法还是第一次看见\n      let end;\n      let attr;\n      // startTagClose 匹配的是闭合标签 attr 匹配的是属性\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        // 根据正则匹配的规则能够将 属性进行分组\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || attr[4] || attr[5]\n        })\n        // 匹配完毕属性之后继续前进，前进多少呢，当前匹配字符串的第0个的length;\n        advance(attr[0].length);\n        // console.log(html);\n      }\n      // 循环完毕属性之后 还会有一个结束标签 我们也要将结束标签去掉\n      if (end) { // >\n        // 如果哦结束标签存在的话,将结束标签也去掉。\n        advance(end[0].length);\n        // match 是一个对象\n        return match // 将 match的结果返回出去,开头的标签匹配宣告结束。\n      }\n    }\n  }\n\n\n  while (html) { // 只要html不为空字符串就一直解析\n    // 首先看看标签是不是以尖角号开头的\n    let textend = html.indexOf('<');\n    // 使用 字符串的indexOf方法 判断如果是0 说明确实是 以 <开头的 肯定是个开头标签\n    if (textend === 0) { \n      // 肯定是标签之后，就开始匹配开始标签\n      const startTagMatch = parseStartTag(); // 这就是开始标签匹配的结果\n      if (startTagMatch) { // 这里需要严谨一些 返回的是一个对象肯定是true\n        start(startTagMatch.tagName, startTagMatch.attrs);\n        // 匹配完开始标签 需要进行下一轮的匹配\n        continue;\n      };\n\n      // 开始匹配结束标签\n      const endTagMatch = html.match(endTag);\n      if (endTagMatch) {\n        // 同样的匹配到的标签删除掉。\n        advance(endTagMatch[0].length)\n        end(endTagMatch[1]);\n        // 结束标签匹配完成就执行下一轮的匹配。\n        continue\n      }\n    }\n    // 如果在下一个 < 的索引是大于0 的说明 第一个 开始标签匹配完之后到第二个开始标签\n    // 中间的部分是有文本的。\n    let text;\n    if (textend > 0) {\n      // substring 这个api的特点是不是包含头部而不包含尾部呢 这个需要确认一下。\n      text = html.substring(0, textend); \n    }\n    // 如果text 存在说明解析到了文本\n    if (text) {\n      advance(text.length); // 继续截取 html \n      chars(text)\n      // console.log(html); // <div id=\"my\">hello {{name}}<span>world</span></div></div>\n    }\n  }\n  // 将这个树返回出去\n  return root;\n}","import { generate } from \"./generate\";\nimport { parseHTML } from \"./parse\";\n\n/**\n * 编译函数 接收一个字符串\n * @param {*} template string\n */\nexport function complileToFunction(template) {\n  // => 将 html字符串变成render函数呢？\n\n  // 1、需要将 html 代码转换成 “ast” 语法树。可以用ast来描述语言本身\n  // const a = 1; 如何用ast来描述这一句话呢\n  // {\n  //   indentifier: const 使用const声明\n  //   name: a\n  //   value: 1\n  // }\n  // 这里需要有一个区分：虚拟dom 是用来描述节点的 而ast可以用来描述语言本身\n  // 前端需要掌握的数据结构 （树）\n  let ast = parseHTML(template); // 将template 转化成ast语法树\n  // 2、通过这颗树 重新生成代码。\n  // console.log(ast);\n  // 3、通过这颗树, 重新生成代码\n  let code = generate(ast);\n  // _c 类似于react中的 createElement \n  // _v 创建文本节点\n  // _s 可以看成是json.stringify();\n  // render() {\n  //   return _c('div', \n  //              { \n  //                id: 'app', \n  //                style: { color: 'red' } \n  //              }, \n  //          _v( 'hello' + _s(name)), _c('span',null, _v('hello'))\n  //          )\n  // }\n  // console.log(code);\n  // 4、将字符串变成函数\n  let render = new Function(`with(this){return ${code}}`)\n  return render\n}","function createEle(vnode) {\n  let { tag, children, key, data, text, vm } = vnode\n  if (typeof tag === \"string\") {\n    // 创建元素放在vnode.el 上\n    vnode.el = document.createElement(tag)\n    children.forEach(child => { // 遍历儿子，将儿子的渲染结果放进父亲中\n      vnode.el.appendChild(createEle(child))\n    })\n  } else {\n    // 创建文本\n    vnode.el = document.createTextNode(text)\n  }\n  return vnode.el\n}\n\nexport function patch(oldVnode, vnode) {\n  if (oldVnode.nodeType == 1) {\n    // 说明是真实的元素\n    // console.log('真实元素');\n    // 用vnode来生成真实的dom，替换虚拟dom\n\n    // 1、首先找到当前dom元素的父元素\n    let parentElment = oldVnode.parentNode\n    // console.log(parentElment)\n\n    // 2、根据虚拟节点创建元素\n    let ele = createEle(vnode)\n\n    // 3、将当前根据虚拟节点创建的元素插入到老元素的后面\n    parentElment.insertBefore(ele, oldVnode.nextSibling)\n\n    // 4、删除老的节点 打完收工\n    parentElment.removeChild(oldVnode)\n    // 将新创建的节点返回出去。\n    return ele\n  }\n}\n","/**\n * 每个属性我都给它分配一个dep dep可以存放watcher\n * 一个属性如果对应100个watcher (vuex中一个state可能在很多个页面中使用)\n * 同样的 watcher中可能存在多个属性, 因为每个属性都给他分配了一个dep 所以watcher中可能存在多个dep\n */\n\n// 为了保证dep的唯一性 也需要用一个id\nlet id = 0\nclass Dep {\n  constructor() {\n    this.id = id++\n    this.subs = [] // 用来存放watcher的\n  }\n  depend() {\n    // 走到这个函数的时候 dep.target 已经存在\n    if (Dep.target) {\n      // Dep.target 就是 watcher 这相当于\n      // watcher 上面有一个方法 addDep 把当前的 dep存进 watcher\n      // 这里还有一个场景 一个页面中多次使用一个变量，不需要重复的渲染，只渲染一次就好\n      Dep.target.addDep(this)\n    }\n  }\n  addSub(watcher) {\n    this.subs.push(watcher)\n  }\n  notify() {\n    this.subs.forEach((watcher) => watcher.update())\n  }\n}\n// 静态属性 全局的就这一份\nDep.target = null\n\n// 提供出去的方法 将watcher 挂载到   Dep.target 属性上面\nexport function pushTarget(watcher) {\n  Dep.target = watcher\n}\n\nexport function popTarget() {\n  Dep.target = null\n}\n\nexport default Dep\n","export function proxy(vm, data, key) {\n  Object.defineProperty(vm, key, {\n    get() {\n      return vm[data][key] // vm._data.a\n    },\n    set(newVal) {\n      // 触发set的时候，会得到这个值\n      vm[data][key] = newVal // vm._data.a = 100;\n    },\n  })\n}\n\nexport function isFunction(val) {\n  return typeof val === \"function\"\n}\n\nexport function isObject(val) {\n  return typeof val === \"object\" && val !== null\n}\n\n// 用一个全局的callbacks 接收用户传递进来的更新回调\nconst callbacks = []\nlet waiting = false\n// 用一个方法依次执行这些回调\nfunction flushCallbacks() {\n  callbacks.forEach((cb) => cb())\n  waiting = false\n}\n\nfunction timer(flushCallbacks) {\n  let timerFn = () => {}\n  if (Promise) {\n    timerFn = () => {\n      Promise.resolve().then(flushCallbacks)\n    }\n  } else if (MutationObserver) {\n    let textNode = document.createTextNode(1)\n    let observe = new MutationObserver(flushCallbacks)\n\n    observe.observe(textNode, {\n      characterData: true,\n    })\n\n    timerFn = () => {\n      textNode.textContent = 3\n    }\n  } else if (setImmediate) {\n    timerFn = () => {\n      setImmediate(flushCallbacks)\n    }\n  } else {\n    timerFn = () => {\n      setTimeout(flushCallbacks)\n    }\n  }\n  timerFn()\n}\n\n// vue2中考虑了兼容性的问题 vue3中不再考虑兼容性问题\nexport function nextTick(cb) {\n  callbacks.push(cb)\n  if (!waiting) {\n    setTimeout(() => {\n      timer(flushCallbacks)\n    }, 0)\n    waiting = true\n  }\n}\n","import { nextTick } from \"../utils\"\n\nlet queue = []\nlet has = {} // 列表维护存放了哪些watcher\n\nfunction flushSchedulerQueue() {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i].run()\n  }\n  queue = []\n  has = {}\n  pending = true\n}\n\nlet pending = false\n// 当前执行栈中，代码执行完毕后，会先清空微任务，再清空宏任务\n// 希望尽早的执行一次更新操作\nexport function queueWatcher(watcher) {\n  const id = watcher.id\n\n  if (has[id] == null) {\n    queue.push(watcher)\n    has[id] = true\n    // 开启一次更新操作\n    if (!pending) {\n      nextTick(flushSchedulerQueue, 0)\n      pending = true\n    }\n  }\n}\n","import { popTarget, pushTarget } from \"./dep\"\nimport { queueWatcher } from \"./scheduler\"\n\nlet id = 0\n\nclass Watcher {\n  /**\n   * @param {*} vm\n   * @param {*} exprOrFn 表达式或者是个函数\n   * @param {*} cb\n   * @param {*} options\n   */\n  constructor(vm, exprOrFn, cb, options) {\n    this.vm = vm\n    // 这里做过备注，在渲染watcher中, exprOrFn 就是那个updateComponent\n    // 对于用户自己写的watcher 这里可能是个 字符串 或者表达式 需要手动处理\n    this.exprOrFn = exprOrFn\n    this.user = !!options.user // 标识是否是用户自己写的watcher\n    this.lazy = !!options.lazy // 是否立即执行get的标志位\n    // 这个dirty默认是脏的, 很巧妙的使用了 lazy的初始值\n    this.dirty = options.lazy\n    this.cb = cb\n    this.options = options\n    // 每 new 一次 watcher 这个id 就会累加\n    this.id = id++\n\n    // 这里需要对 exprOrFn 做一个判断\n    if (typeof exprOrFn == \"string\") {\n      // 将这个表达式转成一个函数 只要new Watcher的时候\n      this.getter = function () {\n        let path = exprOrFn.split(\".\") // [age,n] 分割成数组这种形式\n\n        let obj = vm\n        // 这里有点绕\n        for (let i = 0; i < path.length; i++) {\n          obj = obj[path[i]]\n        }\n        return obj\n      }\n    } else {\n      this.getter = exprOrFn\n    }\n    this.deps = []\n    // 每一个属性对应的是一个dep 这个我其实有点理解不了\n    this.depsId = new Set()\n    // new Watcher 的时候就会执行这个get方法\n    // 而这个get方法执行实际上就是我们传递进来 updateComponent 函数 执行\n    // 在用户自定义的watcher中 第一次调用get 方法就能拿到返回值\n    this.value = this.lazy ? undefined : this.get()\n  }\n  // 默认应该让exprOrFn执行 就是updateComponent这个方法 render 去vm上取值 每次取的都是新的值\n  get() {\n    // 在执行取值之前，先把这个watcher放进dep的target属性上\n    pushTarget(this)\n    // 每个属性都能收集自己的watcher\n    // 当我们执行 这个get方法的时候 会从defineProperty 执行get方法\n    // 每个属性都可以收集自己的watcher\n    // 每个组件都拥有一个渲染watcher 组件有100个属性，那这100个属性都是属于这一个渲染watcher的\n    // 对于vuex的使用场景来说，一个state 会在多个页面中用到，那这一个属性 对应的是多个 watcher\n    // 当这个state变化了，是需要通知多个watcher一起更新的\n\n    // 走到这个函数的时候 会从vm上取值，\b因为data上的属性已经被响应式了 会触发get方法\n    const value = this.getter.call(this.vm)\n\n    // 如果用户在模板外面取值，我们是不需要依赖收集的，此时清空\n    popTarget()\n\n    return value\n  }\n  update() {\n    // this.get()\n    // 对于多次修改属性的情况，我们只希望执行一次更新的操作，这种情况下\n    // 最好的就是对watcher做一个防抖的控制 限制它的更新频率\n    // 多次调用watcher 我希望缓存起来，等一下一起更新\n    // 所以说 vue中的更新操作是异步的\n    queueWatcher(this)\n  }\n  run() {\n    let newValue = this.get()\n    let oldValue = this.value\n\n    this.value = newValue // 为了保证下一次的更新时，上一次的最新值是下一次的老值\n\n    if (this.user) {\n      this.cb.call(this.vm, newValue, oldValue)\n    }\n  }\n  addDep(dep) {\n    // 同一个属性在响应式的时候 有一个id属性\n    // 将这个id取出来\n    let id = dep.id\n    // 这里使用的set去重\n    if (!this.depsId.has(id)) {\n      // id 不存在 就将这个dep id 放进去\n      this.depsId.add(id)\n      // 然后将dep放进去  在页面中 可能使用多个属性 age name xxx\n      // 一个watcher 存放多个dep\n      this.deps.push(dep)\n      // 同样的 需要在dep中存放watcher （其实这里并不是很明白 为什么要让dep记住watcher ）\n      // 想想 vuex中的例子就知道了 dep 记录所有的 watcher\n      dep.addSub(this)\n    }\n  }\n  evaluate() {\n    this.dirty = false // 表示已经取过值了\n    this.value = this.get() // 这个就是用户的getter执行，把这个值返回\n  }\n}\n\nexport default Watcher\n","import { patch } from \"./vdom/patch\";\nimport Watcher from \"./observer/watcher\";\nimport { nextTick } from \"./utils\";\n\nexport function lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode) {\n    // 这个方法既在初始化的时候调用，也会在更新的情况下调用\n    const vm = this;\n    vm.$el = patch(vm.$el, vnode)\n  }\n  // 用户自己调用的nextTick 也是这个方法\n  Vue.prototype.$nextTick = nextTick\n}\n\nexport function mountComponent(vm, el) {\n  // 更新函数 数据变化后，会再次调用这个函数\n  let updateComponent = () => {\n    // 在这个函数的内部核心只做了两件事情:\n    //    1、调用render方法生成虚拟dom \n    //    2、使用render方法渲染真实的dom\n    // 后续更新可以调用 updateComponent 这个方法\n    // 这里有一个细节需要注意, 在调用render的时候，会从vm上取值，必然触发 vm 上属性的get操作\n    vm._update(vm._render())\n  }\n  // 第一次渲染的时候先调用一次\n  // vue中视图更新是通过观察者模式实现的\n  // 属性:  被观察者  观察者:刷新页面\n  // 第一个参数是vm: 当前的实例 \n  // 第二个参数是更新方法，也就是 updateComponent 这个方法\n  // 第三个参数是回调函数,就是更新完毕之后，需要执行的函数\n  // 第四个参数 是一个标识，代表的是渲染watcher \n  /**\n   * true 渲染watcher 说明还有其他 watcher\n   * 进行渲染的时候会创建一个watcher\n   * 有了watcher 之后 我们希望属性能和watcher有一个关联\n   */\n  new Watcher(vm, updateComponent, () => {\n    console.log('我更新了');\n  }, true)\n}\n","let oldArrayPrototype = Array.prototype\n/**\n * 每一个构造函数都拥有一个prototype属性\n * 每一个对象被创建的时候都拥有原型对象\n * 每一个对象通过__proto__属性访问到自己的原型对象\n */\nexport let arrayMethods = Object.create(oldArrayPrototype)\n// arrayMethods.__proto__ = Array.prototype\n\n// 下面的这7个方法要记住呀，非常的重要呀\nlet methods = [\"push\", \"shift\", \"unshift\", \"pop\", \"reverse\", \"sort\", \"splice\"]\n\n// 下面这个写法非常重要，要注意了\nmethods.forEach((method) => {\n  // arrayMethods 是一个对象 对象的每一个方法都是一个函数\n  // 用户只要使用这7个方法，就会走到自己写的方法中。从而做到了数组劫持\n  // 你看：虽然看似是数组劫持，其实是考察原型链的继承\n  arrayMethods[method] = function (...args) {\n    // 用户传递进来的参数列表 arr.push(1,2,3) ...args = [1,2,3]\n    // 这里我之前一直不是很理解 其实这里 ...args 就是一个整体\n    // 这里的this指向的是谁？ 谁调用就是谁 我们最终会使用 vm.arr.push() pop() 那this就是 数组\n    // 这里数组没有监控索引的变化\n    oldArrayPrototype[method].call(this, ...args)\n\n    let inserted;\n    // 这部分有些绕，绕的地方主要是两个this指的是啥\n    // 这里的this 对应的是当前的数组 __ob__ 属性对应的是Observe实例\n    let ob = this.__ob__; // 这是一个自定义的属性 \n    // 对于数组的新增方法 需要做处理\n    switch (method) {\n      case 'push': // arr.push({a:1},{b:2})\n      case 'unshift': // 这两个方法 都是追加，追加的内容可能是对象类型 应该被再次进行劫持\n        inserted = args // 将args 赋值给这个需要插入的变量\n        break;\n      case 'splice': // vue.$set的原理\n        inserted = args.slice(2); // arr.splice(0,1,{a:1})\n      default:\n        break;\n    }\n\n    if (inserted) {\n      // 为了拿到observe 实例上面的 observeArray 方法 \n      // 先提前将 这个实例绑定到了数组上面\n      inserted = ob.observeArray(inserted); // 给数组新增的值也要进行观测\n    }\n    // 数组本身的watcher 更新\n    ob.dep.notify();\n  }\n})\n","import { isObject } from \"../utils\"\nimport { arrayMethods } from \"./array\"\nimport Dep from \"./dep\"\n\n\n\nfunction dependArray(value) {\n  for(let i = 0;i< value.length;i++) {\n    // 这个 current 是数组中的数组 \n    let current = value[i];\n    current.__ob__ && current.__ob__.dep.depend();\n\n    if(Array.isArray(current)) {\n      dependArray(current)\n    }\n  }\n}\n\n/**\n * vue2会对对象进行遍历，将每个属性 用defineProperty 重新定义 性能差\n * defineReactive 是一个包装 内部就是使用\n * @param {*} data\n * @param {*} key\n * @param {*} value\n */\nfunction defineReactive(data, key, value) {\n  /**\n   * 你看这很显然就是一个递归的操作，发现对象里面嵌套对象\n   * 还是可以进一步的做响应式的处理\n   */\n  let childOb =  observe(value)\n  // 这个value值也可能是一个数组，defineProperty 本身是不涉及value的\n  // 这个value 是通过 defineReactive 这个函数传递进来的\n  // 这个 defineReactive 每个属性都会执行, 在这里 创建一个dep\n  let dep = new Dep()\n  Object.defineProperty(data, key, {\n    // 取值的时候创建一个dep\n    get() {\n      // 渲染之前的时候先将watcher放在了dep.target上\n      // 然后将dep.target 置空 这样 在模板下面取值时候就不会依赖收集\n      if (Dep.target) {\n        dep.depend(); // 让dep记住watcher 这个是比较核心的逻辑\n        if (childOb) {\n          childOb.dep.depend();\n\n          // 对于数组中子元素还是数组的情况，还需要做依赖收集\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      // console.log(key)\n      return value\n    },\n    set(newV) {\n      /**\n       * 如果用户赋值一个新的对象 需要将这个对象进行劫持\n       */\n      if(newV !== value) {\n        observe(newV)\n        value = newV\n        // 告诉当前的属性存放的watcher执行\n        dep.notify()\n      }\n    },\n  })\n}\n\n// 如果我们给对象新增一个属性并不会触发视图更新，为了解决这个问题，我们可以给（对象本身也增加一个dep  dep存watcher） 如果\n// 增加一个属性后，我们就手动触发watcher的更新 这就是$set的实现原理。 \nclass Observer {\n  constructor(data) {\n\n    this.dep = new Dep();\n\n    // 这里使用defineProperty 定义一个 __ob__ 属性\n    // object.defineProperty 方法会直接在一个对象上定义一个新属性。\n    // 或者修改一个对象的现有属性，并返回此对象。判断一个对象是否被观测过，看它有没有 __ob__ 属性\n    // 注意 使用这个方法定义的属性是不会被枚举的到，不可枚举的好处是不会造成死循环，这里写的真的很好\n    Object.defineProperty(data, \"__ob__\", {\n      enumerable: false,\n      configurable: false,\n      value: this,\n    })\n\n    if (Array.isArray(data)) {\n      // 对于对象来说，我们可以给他的属性添加dep，那对于数组该如何处理呢\n\n\n      // 数组的处理 对数组原来的方法进行改写，这种思路就是面向切面编程\n      // 虽然在最后还是会调用数组原来的方法，但是会在外面包一层函数,\n      // 可以在包装的这层函数中加入自己的一些逻辑——高阶函数\n      // 在学习这部分的内容时候对于原型的理解终究是有些模糊，推荐一篇文章\n      // https://github.com/mqyqingfeng/Blog/issues/2\n      // 文章中有一句话说的特别清晰：每一个JavaScript对象 (null) 除外都拥有__proto__属性 指向它的原型对象\n      data.__proto__ = arrayMethods\n\n      // 这里还需要处理一种情况，如果数组中的元素还是数组，或者数组中的元素是对象，\n      // 我们原则上是需要支持观测内部对象变化的，虽然vue中对于数组没有监控索引的变化\n      // 但是针对数组中元素是对象的情况还是做了处理。\n      this.observeArray(data)\n    } else {\n      // 对象的处理\n      this.work(data)\n    }\n  }\n  /**\n   * 观测对象\n   * @param {*} data\n   */\n  observeArray(data) {\n    // 对数组的每一项进行观测。\n    data.forEach((item) => {\n      observe(item)\n    })\n  }\n  /**\n   * data 是一个对象 遍历对象使用object.keys\n   * 这个方法已经很常见了。返回的是一个数组 数组的所有元素\n   * 由这个对象的key组成\n   * 划重点是所有的属性做响应式，哈哈哈，这部分一直迷糊\n   * @param {*} data\n   */\n  work(data) {\n    // console.log(Object.keys(data))  [\"name\", \"showFlag\"]\n    // 这里使用object.keys不会遍历原型上的属性\n    Object.keys(data).forEach((key) => {\n      // 将对象中的每一个「属性」！！！都进行响应式处理\n      defineReactive(data, key, data[key])\n    })\n  }\n}\n\n/**\n * 这个函数接收的是 处理后的data了，还记得在initState中\n * 对data的处理吗，如果判断是函数，就拿到函数的执行结果\n * 并且使用call来绑定this指向防止迷路。\n * @param {*} data\n * @returns\n */\nexport function observe(data) {\n  // 响应式部分是针对对象来说的，如果不是对象直接略过\n  if (!isObject(data)) {\n    return\n  }\n\n  // 这里做一个判断，如果当前的这个数据已经被响应式了\n  // 直接返回就好，不需要重复响应式，最初添加这个属性是在Observer 这个类中做的\n  // 所以被观测的属性，都具有 __ob__ 属性  这个属性的值 还记得是什么吗 是那个 observer 实例\n  if (data.__ob__) {\n    return data.__ob__;\n  }\n\n  // 这里使用了一个类，之所以没有使用构造函数的原因是\n  // 功能比较耦合,返回的是一个实例\n  return new Observer(data)\n}\n","import { observe } from \"./observer/index.js\"\nimport { proxy } from \"./utils\"\nimport Watcher from \"./observer/watcher\"\n\nexport function stateMixin(Vue) {\n  /**\n   *\n   * @param {*} key\n   * @param {*} handler\n   * @param {*} options 可以接收用户传参立即调用\n   */\n  Vue.prototype.$watch = function (key, handler, options = {}) {\n    options.user = true // 标识是用户自己写的watcher\n    /**\n     * 原型上的方法  this指向当前实例\n     */\n    new Watcher(this, key, handler, options)\n  }\n}\n\n/**\n * 初始化数据处理函数 接收的参数是vm实例了\n * 因为很多组件的实例都是需要进行初始数据的\n * @param {*} vm\n */\nexport function initState(vm) {\n  // 还记得在 init.js 中将用户传递的 options 赋值给 vm.$options\n  // 这里可以直接取出来使用了\n  const opts = vm.$options\n  if (opts.props) {\n    initProps(vm)\n  }\n  if (opts.methods) {\n    initMethod(vm)\n  }\n  if (opts.data) {\n    // 初始化data\n    initData(vm)\n  }\n  if (opts.computed) {\n    initComputed(vm, opts.computed)\n  }\n  if (opts.watch) {\n    initWatch(vm, opts.watch)\n  }\n}\n/**\n * 这个函数专门用来处理用户传递进来的data\n * 我们写过vue的都知道，这个data中一般存放的都是页面\n * 中用于显示的响应式数据 比方说一些 tableList 还是一些展示标志位\n * @param {*} vm\n */\nfunction initData(vm) {\n  let data = vm.$options.data\n  // 这里使用 isFunction 工具函数判断传入的data是不是一个函数\n  // 如果是一个函数就执行这个函数，但是执行时候需要绑定vm,因为我们希望在整个执行的过程中\n  // this始终指向vm，也就是当前new出来的实例。\n  // 使用_data 和 data 做一个关联 两者使用同一份引用地址\n  vm._data = data = typeof data === \"function\" ? data.call(vm) : data\n\n  for (let key in data) {\n    proxy(vm, \"_data\", key)\n  }\n  // vue2中会将data中的所有数据 进行数据劫持 Object.defineProperty\n  observe(data)\n}\nfunction initProps() {}\nfunction initMethod() {}\n\n/**\n *\n * @param {*} vm\n * @param {*} computed\n */\nfunction initComputed(vm, computed) {\n  // 我希望做一个关联，将key 和watcher做一个关联\n  // 在vm 上面放置一个属性_computedWatchers 和 watchers 用的是同一个对象\n  const watchers = (vm._computedWatchers = {})\n\n  // 为什么这里需要循环，因为计算属性很多，我需要创建多个watcher\n  // computed 有两种写法 我平时习惯使用第一中 那种get 个 set的 不经常使用\n  for (let key in computed) {\n    // 首先传递参数的时候 也是以对象的形式传递进来的\n    // 用户定义的\n    const userDef = computed[key]\n\n    // 依赖的属性变化就是重新取值\n    // 这里做个简单的判断，如果是函数，那当前这个函数就是getter\n    // 如果是对象 对象的get 方法就是要的那个值\n    let getter = typeof userDef === \"function\" ? userDef : userDef.get\n\n    /**\n     * 感觉watcher 这个概念真的好难呀 有点理解不了\n     * computed 默认是不直接执行的 所以在options\n     * 选项中 lazy 设置为true 不要默认执行\n     * 将watcher 和属性做一个映射 相当于一个map\n     */\n    watchers[key] = new Watcher(vm, getter, () => {}, { lazy: true })\n\n    // 将key 定义在vm上\n    defineComputed(vm, key, userDef)\n  }\n}\n\n/**\n * 首先这个函数存在的意义是什么呢\n * 就是做一个缓存的功能，不要轻易触发getter方法\n * 这就是一个高阶函数\n */\nfunction createComputedGetter(key) {\n  // 取计算属性值的时候 走的是这个函数\n  // 只要createComputedGetter 函数执行\n  return function computedGetter() {\n    // 这里的this 指的就是vm  this._computedWatchers 包含\n    // 所有的计算属性 通过key 可以拿到对应的watcher wather 中包含对应的watcher\n    let watcher = this._computedWatchers[key]\n\n    // 看这个watcher是不是脏的 根据这个属性判断是否可以重新执行\n    // 脏就是调用用户的getter 不脏就是不用调用用户的getter\n    if (watcher.dirty) {\n      watcher.evaluate()\n    }\n\n    return watcher.value\n  }\n}\n\n/**\n *\n * @param {*} vm\n * @param {*} key\n * @param {*} userDef\n */\nfunction defineComputed(vm, key, userDef) {\n  let sharedProperty = {}\n\n  if (typeof userDef === \"function\") {\n    sharedProperty.get = userDef\n  } else {\n    sharedProperty.get = createComputedGetter(key)\n    sharedProperty.set = userDef.set\n  }\n  // 本质上还是一个 Object.defineProperty\n  // 定义在vm 上的 属性key 传入的 get 和 set 做了处理\n  Object.defineProperty(vm, key, sharedProperty)\n}\n\n/**\n *\n * @param {*} vm\n * @param {*} watch\n */\nfunction initWatch(vm, watch) {\n  // watch 传入的是一个对象 这里需要循环一下，拿到每一个key\n\n  for (let key in watch) {\n    let handler = watch[key]\n\n    // 一个 属性可以接收多个回调函数，所以这里 handler 可能是个数组\n    if (Array.isArray(handler)) {\n      for (let i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i])\n      }\n    } else {\n      // 如果不是一个数组，那就是一个简单的函数\n      createWatcher(vm, key, handler)\n    }\n  }\n}\n\n/**\n * 创建watcher\n */\nfunction createWatcher(vm, key, handler) {\n  // 用户可能直接使用 vm.$watch 这种形式调用。\n  // 我们需要在原型上定义 $watch 方法\n  return vm.$watch(key, handler)\n}\n","import { complileToFunction } from \"./compiler/index.js\"\nimport { mountComponent } from \"./lifecycle.js\"\nimport { initState } from \"./state\"\n\n/**\n * 将构造函数作为参数传递进去，对构造函数进行扩展，\n * 这里使用了在构造函数的原型上进行扩展的方式，所有的组件实例均可以共享\n * 表示在vue的基础上做一次混合操作\n * 这种设计思想也是非常值得借鉴的。\n * @param {*} Vue\n */\nexport function initMixin(Vue) {\n  // 扩展原型上的方法\n  Vue.prototype._init = function (options) {\n    // 原型方法中的this指向实例 所有的实例都具有这些方法，\n    // 这里用vm表示this的引用比较方便识别。假设在这个函数中\n    // 直接有一个函数声明，函数声明中的this就不好说是谁了。\n    // 但是可以在函数中使用vm,这个就特别类似于 var that = this 那种写法\n    const vm = this\n    // 用户传递进来的options属性挂载到vm上面, 这时我们能够操作vm.$options\n    vm.$options = options\n    // 初始化状态 模板渲染的数据需要这个函数  不仅仅是有watch 还有computed props data 我们需要有一个统一的函数\n    // 来处理这些参数。用户也是将不同的状态放在不同的对象下面进行维护\n    initState(vm)\n    // 数据初始化就这样结束了吗？ 当然没有 我们还需要将数据挂载到模板上面\n    if (vm.$options.el) {\n      // 将数据挂载到模板上\n      vm.$mount(vm.$options.el)\n    }\n  }\n  /**\n   * 这个就是那个渲染的方法\n   * 我们说，如果每次数据变化，就全部将模板替换，这种方式是很低效的\n   * 因为vue2 中将模板转换成渲染函数，函数的执行效率要高很多。\n   * 并且引入了虚拟dom的概念，每次数据变化，生成虚拟节点。而不是真正的操作dom\n   * @param {*} el\n   */\n  Vue.prototype.$mount = function (el) {\n    const vm = this\n    const options = vm.$options\n    el = document.querySelector(el)\n    vm.$el = el\n    // 这里解释下为什么要做这个判断，因为会有情况是用户手动写render方法\n    // 这种情况下用户手写的render优先级要更高一些。这个函数的终极目标是帮助我们\n    // 创建出虚拟节点\n    // 这部分信息量比较大，我们可以在options的选项中添加 template 字段\n    // 如果没写，才使用 html中写的dom节点，这点应该尤其注意\n    if (!options.render) {\n      let template = options.template\n      if (!template) {\n        template = el.outerHTML\n        // 下面这一行打印的是字符串\n        // console.log(template) <div id=\"app\">{{name}}</div>\n        // 这个函数是一个核心的函数，将我们传递进去的模板编译成 render函数\n        let render = complileToFunction(template)\n        options.render = render\n      }\n    }\n    // 调用render方法 渲染成真实的dom替换掉页面的内容\n    // 这个方法是定义在生命周期这个包中的\n    mountComponent(vm, el)\n  }\n}\n","// 专门有一个包来处理虚拟节点\nexport function createElement(vm, tag, data = {}, ...children) {\n  return vnode(vm, tag, data, data.key, children, undefined)\n}\n\nexport function createTextElement(vm, text) {\n  return vnode(vm, undefined, undefined, undefined, undefined, text)\n}\n\nfunction vnode(vm, tag, data, key, children, text) {\n  return {\n    vm,\n    tag,\n    data,\n    key,\n    children,\n    text,\n  }\n}\n","import { createElement, createTextElement } from \"./vdom/index\"\n\nexport function renderMixin(Vue) {\n  Vue.prototype._c = function () {\n    // createElement\n    return createElement(this, ...arguments)\n  }\n  Vue.prototype._v = function (text) {\n    // createTextElement\n    return createTextElement(this, text)\n  }\n  Vue.prototype._s = function (val) {\n    if (typeof val === \"object\") {\n      return JSON.stringify(val)\n    }\n    return val\n  }\n  Vue.prototype._render = function () {\n    const vm = this\n    let render = vm.$options.render // 这个render 就是我们解析出来的render方法 同时也有可能是用户自己写的render\n\n    let vnode = render.call(vm)\n\n    return vnode\n  }\n}\n","import { initMixin } from \"./init\"\nimport { lifecycleMixin } from \"./lifecycle\";\nimport { renderMixin } from \"./render\";\nimport { stateMixin } from \"./state\";\n\n/**\n * 这里是一个函数声明，只有在new的时候才会调用\n * 接收一个 options 作为参数，options 是一个对象\n * 这个options就是用户传递进来的配置选项\n * 这个配置选项中包含 data el watch computed methods。。。\n * 一些列的参数，在使用vue-cli脚手架进行开发的时候\n * 都是单组件文件 每个组件本质上都是一个实例\n * @param {*} options \n */\nfunction Vue(options) {\n  // options 为用户传入的选项\n  this._init(options) // 初始化操作\n}\n\n// 只要加载了index.js 这个文件下面的函数都会执行\n// 并且是首先执行的，那么所有在mixin上挂载的所有原型\n// 方法都会预先定义执行，init 是在new 的时候执行的\ninitMixin(Vue);\nstateMixin(Vue);\nrenderMixin(Vue);  // 存放的是 _render\nlifecycleMixin(Vue); // 存放的是 _update\n\n// 将vue导出\nexport default Vue\n"],"names":["defaultTagRE","genProps","attrs","str","i","length","attr","name","obj","value","split","forEach","item","key","JSON","stringify","slice","gen","node","type","generate","text","test","tokens","lastIndex","match","index","exec","push","trim","join","genChildren","el","children","map","child","code","tag","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","createASTElement","tagName","parent","root","currentParent","stack","start","element","end","pop","chars","replace","advance","n","substring","parseStartTag","textend","indexOf","startTagMatch","endTagMatch","complileToFunction","template","ast","render","Function","createEle","vnode","data","vm","document","createElement","appendChild","createTextNode","patch","oldVnode","nodeType","parentElment","parentNode","ele","insertBefore","nextSibling","removeChild","id","Dep","subs","target","addDep","watcher","update","pushTarget","popTarget","proxy","Object","defineProperty","get","set","newVal","isObject","val","callbacks","waiting","flushCallbacks","cb","timer","timerFn","Promise","resolve","then","MutationObserver","textNode","observe","characterData","textContent","setImmediate","setTimeout","nextTick","queue","has","flushSchedulerQueue","run","pending","queueWatcher","Watcher","exprOrFn","options","user","lazy","dirty","getter","path","deps","depsId","Set","undefined","call","newValue","oldValue","dep","add","addSub","lifecycleMixin","Vue","prototype","_update","$el","$nextTick","mountComponent","updateComponent","_render","console","log","oldArrayPrototype","Array","arrayMethods","create","methods","method","args","inserted","ob","__ob__","observeArray","notify","dependArray","current","depend","isArray","defineReactive","childOb","newV","Observer","enumerable","configurable","__proto__","work","keys","stateMixin","$watch","handler","initState","opts","$options","props","initData","computed","initComputed","watch","initWatch","_data","watchers","_computedWatchers","userDef","defineComputed","createComputedGetter","computedGetter","evaluate","sharedProperty","createWatcher","initMixin","_init","$mount","querySelector","outerHTML","createTextElement","renderMixin","_c","arguments","_v","_s"],"mappings":"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"}