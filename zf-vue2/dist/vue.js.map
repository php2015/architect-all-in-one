{"version":3,"file":"vue.js","sources":["../src/compliler/index.js","../src/utils.js","../src/observer/array.js","../src/observer/index.js","../src/state.js","../src/init.js","../src/index.js"],"sourcesContent":["export function complileToFunction(template) {\n  console.log(template)\n}\n","export function proxy(vm, data, key) {\n  Object.defineProperty(vm, key, {\n    get() {\n      return vm[data][key]; // vm._data.a\n    },\n    set(newVal) { // 触发set的时候，会得到这个值\n      vm[data][key] = newVal; // vm._data.a = 100;\n    }\n  })\n}\n\nexport function isFunction(val) {\n  return typeof val === \"function\"\n}\n\nexport function isObject(val) {\n  return typeof val === \"object\" && val !== null\n}\n","let oldArrayPrototype = Array.prototype\n/**\n * 每一个构造函数都拥有一个prototype属性\n * 每一个对象被创建的时候都拥有原型对象\n * 每一个对象通过__proto__属性访问到自己的原型对象\n */\nexport let arrayMethods = Object.create(oldArrayPrototype)\n// arrayMethods.__proto__ = Array.prototype\n\n// 下面的这7个方法要记住呀，非常的重要呀\nlet methods = [\"push\", \"shift\", \"unshift\", \"pop\", \"reverse\", \"sort\", \"splice\"]\n\n// 下面这个写法非常重要，要注意了\nmethods.forEach((method) => {\n  // arrayMethods 是一个对象 对象的每一个方法都是一个函数\n  // 用户只要使用这7个方法，就会走到自己写的方法中。从而做到了数组劫持\n  // 你看：虽然看似是数组劫持，其实是考察原型链的继承\n  arrayMethods[method] = function (...args) {\n    // 用户传递进来的参数列表 arr.push(1,2,3) ...args = [1,2,3]\n    // 这里我之前一直不是很理解 其实这里 ...args 就是一个整体\n    // 这里的this指向的是谁？ 谁调用就是谁 我们最终会使用 vm.arr.push() pop() 那this就是 数组\n    // 这里数组没有监控索引的变化\n    oldArrayPrototype[method].call(this, ...args)\n\n    let inserted;\n    // 这部分有些绕，绕的地方主要是两个this指的是啥\n    // 这里的this 对应的是当前的数组 __ob__ 属性对应的是Observe实例\n    let ob = this.__ob__; // 这是一个自定义的属性 \n    // 对于数组的新增方法 需要做处理\n    switch (method) {\n      case 'push': // arr.push({a:1},{b:2})\n      case 'unshift': // 这两个方法 都是追加，追加的内容可能是对象类型 应该被再次进行劫持\n        inserted = args // 将args 赋值给这个需要插入的变量\n        break;\n      case 'splice': // vue.$set的原理\n        inserted = args.slice(2); // arr.splice(0,1,{a:1})\n      default:\n        break;\n    }\n\n    if (inserted) {\n      // 为了拿到observe 实例上面的 observeArray 方法 \n      // 先提前将 这个实例绑定到了数组上面\n      inserted = ob.observeArray(inserted); // 给数组新增的值也要进行观测\n    }\n  }\n})\n","import { isObject } from \"../utils\"\nimport { arrayMethods } from \"./array\"\n\n/**\n * vue2会对对象进行遍历，将每个属性 用defineProperty 重新定义 性能差\n * defineReactive 是一个包装 内部就是使用\n * @param {*} data\n * @param {*} key\n * @param {*} value\n */\nfunction defineReactive(data, key, value) {\n  /**\n   * 你看这很显然就是一个递归的操作，发现对象里面嵌套对象\n   * 还是可以进一步的做响应式的处理\n   */\n  observe(value)\n  Object.defineProperty(data, key, {\n    get() {\n      return value\n    },\n    set(newV) {\n      /**\n       * 如果用户赋值一个新的对象 需要将这个对象进行劫持\n       */\n      observe(newV)\n      value = newV\n    },\n  })\n}\n/**\n * 对象没有类型 类有类型 使用类的话入参会在构造函数中被作为参数，接收到\n *\n */\nclass Observer {\n  constructor(data) {\n    // 这里使用defineProperty 定义一个 __ob__ 属性\n    // object.defineProperty 方法会直接在一个对象上定义一个新属性。\n    // 或者修改一个对象的现有属性，并返回此对象。判断一个对象是否被观测过，看它有没有 __ob__ 属性\n    // 注意 使用这个方法定义的属性是不会被枚举的到，不可枚举的好处是不会造成死循环，这里写的真的很好\n    Object.defineProperty(data, \"__ob__\", {\n      enumerable: false,\n      configurable: false,\n      value: this,\n    })\n\n    if (Array.isArray(data)) {\n      // 数组的处理 对数组原来的方法进行改写，这种思路就是面向切面编程\n      // 虽然在最后还是会调用数组原来的方法，但是会在外面包一层函数,\n      // 可以在包装的这层函数中加入自己的一些逻辑——高阶函数\n      // 在学习这部分的内容时候对于原型的理解终究是有些模糊，推荐一篇文章\n      // https://github.com/mqyqingfeng/Blog/issues/2\n      // 文章中有一句话说的特别清晰：每一个JavaScript对象 (null) 除外都拥有__proto__属性 指向它的原型对象\n      data.__proto__ = arrayMethods\n\n      // 这里还需要处理一种情况，如果数组中的元素还是数组，或者数组中的元素是对象，\n      // 我们原则上是需要支持观测内部对象变化的，虽然vue中对于数组没有监控索引的变化\n      // 但是针对数组中元素是对象的情况还是做了处理\n      this.observeArray(data)\n    } else {\n      // 对象的处理\n      this.work(data)\n    }\n  }\n  /**\n   * 观测对象\n   * @param {*} data\n   */\n  observeArray(data) {\n    // 对数组的每一项进行观测。\n    data.forEach((item) => {\n      observe(item)\n    })\n  }\n  /**\n   * data 是一个对象 遍历对象使用object.keys\n   * 这个方法已经很常见了。返回的是一个数组 数组的所有元素\n   * 由这个对象的key组成\n   * 划重点是所有的属性做响应式，哈哈哈，这部分一直迷糊\n   * @param {*} data\n   */\n  work(data) {\n    // console.log(Object.keys(data))  [\"name\", \"showFlag\"]\n    // 这里使用object.keys不会遍历原型上的属性\n    Object.keys(data).forEach((key) => {\n      // 将对象中的每一个「属性」！！！都进行响应式处理\n      defineReactive(data, key, data[key])\n    })\n  }\n}\n\n/**\n * 这个函数接收的是 处理后的data了，还记得在initState中\n * 对data的处理吗，如果判断是函数，就拿到函数的执行结果\n * 并且使用call来绑定this指向防止迷路。\n * @param {*} data\n * @returns\n */\nexport function observe(data) {\n  // 响应式部分是针对对象来说的，如果不是对象直接略过\n  if (!isObject(data)) {\n    return\n  }\n\n  // 这里做一个判断，如果当前的这个数据已经被响应式了\n  // 直接返回就好，不需要重复响应式，最初添加这个属性是在Observer 这个类中做的\n  // 所以被观测的属性，都具有 __ob__ 属性\n  if (data.__ob__) {\n    return data\n  }\n\n  // 这里使用了一个类，之所以没有使用构造函数的原因是\n  // 功能比较耦合,返回的是一个实例\n  return new Observer(data)\n}\n","import { observe } from \"./observer/index.js\"\nimport { isFunction, proxy } from \"./utils\"\n\n/**\n * 初始化数据处理函数 接收的参数是vm实例了\n * 因为很多组件的实例都是需要进行初始数据的\n * @param {*} vm\n */\nexport function initState(vm) {\n  // 还记得在 init.js 中将用户传递的 options 赋值给 vm.$options\n  // 这里可以直接取出来使用了\n  const opts = vm.$options\n  if (opts.props) {\n    initProps(vm)\n  }\n  if (opts.methods) {\n    initMethod(vm)\n  }\n  if (opts.data) {\n    // 初始化data\n    initData(vm)\n  }\n  if (opts.computed) {\n    initComputed(vm)\n  }\n  if (opts.watch) {\n    initWatch(vm)\n  }\n}\n/**\n * 这个函数专门用来处理用户传递进来的data\n * 我们写过vue的都知道，这个data中一般存放的都是页面\n * 中用于显示的响应式数据 比方说一些 tableList 还是一些展示标志位\n * @param {*} vm\n */\nfunction initData(vm) {\n  let data = vm.$options.data\n  // 这里使用 isFunction 工具函数判断传入的data是不是一个函数\n  // 如果是一个函数就执行这个函数，但是执行时候需要绑定vm,因为我们希望在整个执行的过程中\n  // this始终指向vm，也就是当前new出来的实例。\n  // 使用_data 和 data 做一个关联 两者使用同一份引用地址\n  vm._data = data = typeof data === \"function\" ? data.call(vm) : data\n\n  for (let key in data) {\n    proxy(vm, \"_data\", key)\n  }\n\n  // vue2中会将data中的所有数据 进行数据劫持 Object.defineProperty\n  observe(data)\n}\nfunction initProps() {}\nfunction initMethod() {}\nfunction initComputed() {}\nfunction initWatch() {}\n","import { complileToFunction } from \"./compliler/index.js\"\nimport { initState } from \"./state\"\n\n/**\n * 将构造函数作为参数传递进去，对构造函数进行扩展，\n * 这里使用了在构造函数的原型上进行扩展的方式，所有的组件实例均可以共享\n * 表示在vue的基础上做一次混合操作\n * 这种设计思想也是非常值得借鉴的。\n * @param {*} Vue\n */\nexport function initMixin(Vue) {\n  // 扩展原型上的方法\n  Vue.prototype._init = function (options) {\n    // 原型方法中的this指向实例 所有的实例 都具有这些方法\n    // 这里用vm表示this的引用比较方便识别。假设在这个函数中\n    // 直接有一个函数声明，函数声明中的this就不好说是谁了。\n    // 但是可以在函数中使用vm,这个就特别类似于 var that = this 那种写法\n    const vm = this\n    // 用户传递进来的选项挂载到上面,我们能够操作 vm.$options\n    vm.$options = options\n    // 初始化状态 为什么要有这个 函数 不仅仅是 有watch\n    // 还有computed props data 我们需要有一个统一的函数\n    // 来处理这些参数。\n    initState(vm)\n    // 数据初始化就这样结束了吗？ 当然没有 我们还需要将数据挂载到模板上面\n    if (vm.$options.el) {\n      // 将数据挂载到模板上\n      vm.$mount(vm.$options.el)\n    }\n  }\n  /**\n   * 这个就是那个渲染的方法\n   * 我们说，如果每次数据变化，就全部将模板替换，这种方式是很低效的\n   * 因为vue2 中将模板转换成渲染函数，函数的执行效率要高很多。\n   * 并且引入了虚拟dom的概念，每次数据变化，生成虚拟节点。而不是真正的操作dom\n   * @param {*} el\n   */\n  Vue.prototype.$mount = function (el) {\n    const vm = this\n    const options = vm.$options\n    el = document.querySelector(el)\n    // 这里解释下为什么要做这个判断，因为会有情况是用户手动写render方法\n    // 这种情况下用户手写的render优先级要更高一些。这个函数的终极目标是帮助我们\n    // 创建出虚拟节点\n    // 这部分信息量比较大，我们可以在options的选项中添加 template 字段\n    // 如果没写，才使用 html中写的dom节点，这点应该尤其注意\n    if (!options.render) {\n      let template = options.template\n      if (!template) {\n        template = el.outerHTML\n        // 下面这一行打印的是字符串\n        // console.log(template) <div id=\"app\">{{name}}</div>\n        // 这个函数是一个核心的函数，将我们传递进去的模板编译成 render函数\n        let render = complileToFunction(template)\n        options.render = render\n      }\n    }\n  }\n}\n","import { initMixin } from \"./init\"\n\n/**\n * 接收一个option作为参数 是一个对象\n * 这个options就是用户传递进来的配置选项\n * 这个配置选项中包含 data el watch computed methods。。。\n * 一些列的参数，在使用vue-cli脚手架进行开发的时候\n * 都是单组件文件 每个组件本质上都是一个实例\n * @param {*} options \n */\nfunction Vue(options) {\n  // options 为用户传入的选项\n  this._init(options) // 初始化操作\n}\n\n// 只要加载了index.js 这个文件下面的函数都会执行\ninitMixin(Vue)\n\n// 将vue导出\nexport default Vue\n"],"names":["complileToFunction","template","console","log","proxy","vm","data","key","Object","defineProperty","get","set","newVal","isObject","val","oldArrayPrototype","Array","prototype","arrayMethods","create","methods","forEach","method","args","call","inserted","ob","__ob__","slice","observeArray","defineReactive","value","observe","newV","Observer","enumerable","configurable","isArray","__proto__","work","item","keys","initState","opts","$options","props","initData","computed","watch","_data","initMixin","Vue","_init","options","el","$mount","document","querySelector","render","outerHTML"],"mappings":"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"}