{"version":3,"file":"vue.js","sources":["../src/compiler/generate.js","../src/compiler/parse.js","../src/compiler/index.js","../src/lifecycle.js","../src/utils.js","../src/observer/array.js","../src/observer/index.js","../src/state.js","../src/init.js","../src/render.js","../src/index.js"],"sourcesContent":["// _c 类似于react中的 createElement \n// _v 创建虚拟节点\n// _s 可以看成是json.stringify();\n// render() {\n//   return _c('div', \n//              { \n//                id: 'app', \n//                style: { color: 'red' } \n//              }, \n//          _v( 'hello' + _s(name)), _c('span',null, _v('hello'))\n//          )\n// }\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; // 匹配双大括号\n// 生成属性方法 比如说 div中包含 {style: {}} \n/**\n * 这个attrs 中就是一个数组\n * @param {*} attrs \n */\nfunction genProps(attrs) {\n  // [\n  //   {name: \"id\", value: \"app\"},\n  //   {name: \"style\", value: \"color: red\"}\n  // ]\n  // console.log(JSON.stringify(attrs)) \n  // [{\"name\":\"id\",\"value\":\"app\"},{\"name\":\"style\",\"value\":\"font-size: 16px; background: yellowgreen;\"}]\n  let str = '';\n  for (let i = 0; i < attrs.length; i++) {\n\n    let attr = attrs[i];\n    // 对于style标签做特殊处理\n    if (attr.name === 'style') {\n      let obj = {};\n      // attr.value 是一个字符串 \"font-size: 16px; background: yellowgreen;\"}\n      // 先用 ; 分割成了 一个数组\n      // [\"font-size: 16px\", \"background: yellowgreen\",\"\"]\n      attr.value.split(';').forEach(item => {\n        // 数组解构的方式\n        if (item !== \"\") { // 如果最后一个属性后面有分号 数组的最后一项就会有一个 空 ”“\n          let [key, value] = item.split(':')\n          obj[key] = value;\n        }\n      });\n      attr.value = obj;\n      // console.log(attr.value) // {font-size: \" 16px\", \" background\": \" yellowgreen\"\n    }\n    str += `${attr.name}:${JSON.stringify(attr.value)},`;\n    // console.log(str) // generate.js:47 id:\"app\",style:{\"font-size\":\" 16px\",\" background\":\" yellowgreen\"},\n  }\n  // slice 方法可以提取字符串的某一个部分，并以新的字符串返回被提取的部分\n  // stringObject.slice(start,stop)\n  // start 开始位置，从某一个位置开始 \n  // stop 结束位置  如果是负数, 意思是从倒着数 返回start 和 stop 中间的部分\n  // 如果stop 不写，则返回的是从start 到结束的部分\n  return `{${str.slice(0, -1)}}`;\n}\n\nfunction gen(node) {\n  if (node.type == 1) {\n    return generate(node)\n  } else { // 如果是文本 \n    let text = node.text; // 获取文本\n    // 如果是普通文本\n    if (!defaultTagRE.test(text)) { // 如果文本中不包含{{}}\n      return `_v(${JSON.stringify(text)})`\n    }\n    let tokens = []; // 存放每一段代码\n    let lastIndex = defaultTagRE.lastIndex = 0; // 如果正则是全局模式，需要每次使用前值为0\n    let match, index; // 每次匹配到的结果\n    while (match = defaultTagRE.exec(text)) {\n      index = match.index;\n      if (index > lastIndex) {\n        tokens.push(JSON.stringify(text.slice(lastIndex, index)))\n      }\n      tokens.push(`_s(${match[1].trim()})`);\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) { // 后面还有一点没完事\n      tokens.push(JSON.stringify(text.slice(lastIndex)));\n    }\n\n    return `_v(${tokens.join('+')})`;\n  }\n}\n\nfunction genChildren(el) {\n  const children = el.children\n  if (children) {\n    return children.map(child => gen(child)).join(',') // 将所有转化后的儿子用逗号拼接起来)\n  }\n}\n\n// 语法层面的转义 将dom结构变成js的语法\n// 看一下元素里面有没有属性 如果有属性就生成属性。\nexport function generate(el) {\n  let children = genChildren(el)\n  // 这里面 el.tag 就是div 这里在写的时候需要特别注意,很容易写错\n  let code = `_c('${el.tag}',${el.attrs.length ? `${genProps(el.attrs)}` : 'undefined'}${children ? `,${genChildren(el)}` : ''})`;\n  return code;\n}","// 解析函数 如何解析这种标签\n{/* <div>hello <span>world</span></div> */ }\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*` // 这个这则匹配的是标签名称 <aa-aa></aa-aa> 类似于这样的东西\nconst qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\"; // 用来获取标签名称\nconst startTagOpen = new RegExp((\"^<\" + qnameCapture)); // 标签开头的正则表达式\nconst endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\")); // y用来匹配闭合标签的\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nconst startTagClose = /^\\s*(\\/?)>/;\n\n// 这里为什么要使用while循环呢,解析完一段就删除，直到字符串为空说明解析完毕\nexport function parseHTML(html) {\n  // 创建AST语法树\n  function createASTElement(tagName, attrs) {\n    return {\n      tag: tagName, // 标签名称\n      type: 1, // 元素类型\n      children: [], // 孩子列表\n      attrs, // 属性集合\n      parent: null // 父元素\n    }\n  }\n  // 根标签\n  let root;\n  // 处理开始标签 接收两个参数 一个是标签名称，一个是属性。\n  let currentParent; // 标识当前的父节点\n  let stack = [];\n\n  /**\n   * 开始标签 标签名称 和属性\n   * @param {*} tagName \n   * @param {*} attrs \n   */\n  function start(tagName, attrs) {\n    // console.log(tagName, attrs, '————————— 开始标签 —————————');\n    // 创建一个元素\n    let element = createASTElement(tagName, attrs);\n    if (!root) { // 如果没有根元素，这个创建的元素就是根元素。\n      root = element;\n    }\n    // 当前解析的标签 保存起来\n    currentParent = element;\n    // 开头的标签名称 放进栈中\n    stack.push(element);\n  }\n\n  // 处理结束标签\n  function end(tagName) { // 在标签闭合出创建父子关系\n    // 结束的时候将最后一个标签取出来\n    let element = stack.pop();\n    // pop 会改变原数组的长度。\n    // 然后取出数组的最后一个当做当前的 父元素\n    currentParent = stack[stack.length - 1];\n\n    if (currentParent) { // 标签闭合的时候可以知道这个标签的父亲\n      element.parent = currentParent;\n      currentParent.children.push(element);\n    };\n\n  }\n\n  // 处理文本\n  function chars(text) {\n    // console.log(text, '————————— 文本标签 —————————');\n    text = text.replace(/\\s/g, ''); //用正则 将文本标签中的空格去掉\n    if (text) { // 去掉空格之后 如果文本还存在\n      currentParent.children.push({\n        type: 3, // 文本类型\n        text\n      })\n    }\n  }\n\n  // 前进方法, 将匹配到的字符串删除掉，继续匹配后面的内容\n  // 这个substring方法：用于提取字符串中介于两个指定下标之间的字符\n  // stringObject.substring(start, stop)\n  // start 这个参数是必须的 一个非负的整数 规定要提取的的子串的第一个字符在stringObject中的位置\n  // stop 比要提取的子串的最后一个字符在stringObject中的位置多1 通俗来说 这是包头不包尾\n  function advance(n) {\n    // 将截取出来的字符串重新赋值给html\n    html = html.substring(n);\n  }\n  // 匹配开始标签\n  function parseStartTag() {\n    // 字符串的match方法可以在字符串内部检索指定的值，或者找到一个或者多个正则表达式的匹配\n    // 这个方法类似于 indexOf 但是它返回固定的值，而不是字符串的位置\n    // stringObject.match(searchValue)\n    // stringObject.match(regexp)\n    // 返回值是存放匹配结果的数组 该数组的内容依赖于 regexp 是否具有全局标志 g\n    const start = html.match(startTagOpen);\n    if (start) { // 匹配到的数组不为空\n      // 创建一个对象\n      const match = {\n        tagName: start[1],\n        attrs: [],\n      }\n      // 传入的这个是 <div 的长度删除开始标签\n      advance(start[0].length);\n      // console.log(html);\n      // 开始匹配属性，这个属性可能有多个，所以这里使用while循环\n      // 循环的条件是 不是闭合标签标签，且属性还没有匹配完毕\n      // 这种写法还是第一次看见\n      let end;\n      let attr;\n      // startTagClose 匹配的是闭合标签 attr 匹配的是属性\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        // 根据正则匹配的规则能够将 属性进行分组\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || attr[4] || attr[5]\n        })\n        // 匹配完毕属性之后继续前进，前进多少呢，当前匹配字符串的第0个的length;\n        advance(attr[0].length);\n        // console.log(html);\n      }\n      // 循环完毕属性之后 还会有一个结束标签 我们也要将结束标签去掉\n      if (end) { // >\n        // 如果哦结束标签存在的话,将结束标签也去掉。\n        advance(end[0].length);\n        // match 是一个对象\n        return match // 将 match的结果返回出去,开头的标签匹配宣告结束。\n      }\n    }\n  }\n\n\n  while (html) { // 只要html不为空字符串就一直解析\n    // 首先看看标签是不是以尖角号开头的\n    let textend = html.indexOf('<');\n    // 使用 字符串的indexOf方法 判断如果是0 说明确实是 以 <开头的 肯定是个开头标签\n    if (textend === 0) { \n      // 肯定是标签之后，就开始匹配开始标签\n      const startTagMatch = parseStartTag(); // 这就是开始标签匹配的结果\n      if (startTagMatch) { // 这里需要严谨一些 返回的是一个对象肯定是true\n        start(startTagMatch.tagName, startTagMatch.attrs);\n        // 匹配完开始标签 需要进行下一轮的匹配\n        continue;\n      };\n\n      // 开始匹配结束标签\n      const endTagMatch = html.match(endTag);\n      if (endTagMatch) {\n        // 同样的匹配到的标签删除掉。\n        advance(endTagMatch[0].length)\n        end(endTagMatch[1]);\n        // 结束标签匹配完成就执行下一轮的匹配。\n        continue\n      }\n    }\n    // 如果在下一个 < 的索引是大于0 的说明 第一个 开始标签匹配完之后到第二个开始标签\n    // 中间的部分是有文本的。\n    let text;\n    if (textend > 0) {\n      // substring 这个api的特点是不是包含头部而不包含尾部呢 这个需要确认一下。\n      text = html.substring(0, textend); \n    }\n    // 如果text 存在说明解析到了文本\n    if (text) {\n      advance(text.length); // 继续截取 html \n      chars(text)\n      // console.log(html); // <div id=\"my\">hello {{name}}<span>world</span></div></div>\n    }\n  }\n  // 将这个树返回出去\n  return root;\n}","import { generate } from \"./generate\";\nimport { parseHTML } from \"./parse\";\n\n/**\n * 编译函数 接收一个字符串\n * @param {*} template string\n */\nexport function complileToFunction(template) {\n  // => 将 html字符串变成render函数呢？\n\n  // 1、需要将 html 代码转换成 “ast” 语法树。可以用ast来描述语言本身\n  // const a = 1; 如何用ast来描述这一句话呢\n  // {\n  //   indentifier: const 使用const声明\n  //   name: a\n  //   value: 1\n  // }\n  // 这里需要有一个区分：虚拟dom 是用来描述节点的 而ast可以用来描述语言本身\n  // 前端需要掌握的数据结构 （树）\n  let ast = parseHTML(template); // 将template 转化成ast语法树\n  // 2、通过这颗树 重新生成代码。\n  // console.log(ast);\n  // 3、通过这颗树, 重新生成代码\n  let code = generate(ast);\n  // _c 类似于react中的 createElement \n  // _v 创建文本节点\n  // _s 可以看成是json.stringify();\n  // render() {\n  //   return _c('div', \n  //              { \n  //                id: 'app', \n  //                style: { color: 'red' } \n  //              }, \n  //          _v( 'hello' + _s(name)), _c('span',null, _v('hello'))\n  //          )\n  // }\n  // console.log(code);\n  // 4、将字符串变成函数\n  let render = new Function(`with(this){return ${code}}`)\n  return render\n}","export function lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode) {\n    console.log(\"update\")\n  }\n}\n\nexport function mountComponent(vm, el) {\n  // 更新函数 数据变化后，会再次调用这个函数\n  let updateComponent = () => {\n    // 在这个函数的内部核心只做了两件事情 1、调用render方法生成虚拟dom 2、使用render方法 渲染真实的dom\n    // 后续更新可以调用 updateComponent 这个方法\n    // 这两个方法实例上都是具备的，说明是挂载在vue原型上面的\n    vm._update(vm._render())\n  }\n  // 第一次渲染的时候先调用一次\n  updateComponent()\n}\n","export function proxy(vm, data, key) {\n  Object.defineProperty(vm, key, {\n    get() {\n      return vm[data][key]; // vm._data.a\n    },\n    set(newVal) { // 触发set的时候，会得到这个值\n      vm[data][key] = newVal; // vm._data.a = 100;\n    }\n  })\n}\n\nexport function isFunction(val) {\n  return typeof val === \"function\"\n}\n\nexport function isObject(val) {\n  return typeof val === \"object\" && val !== null\n}\n","let oldArrayPrototype = Array.prototype\n/**\n * 每一个构造函数都拥有一个prototype属性\n * 每一个对象被创建的时候都拥有原型对象\n * 每一个对象通过__proto__属性访问到自己的原型对象\n */\nexport let arrayMethods = Object.create(oldArrayPrototype)\n// arrayMethods.__proto__ = Array.prototype\n\n// 下面的这7个方法要记住呀，非常的重要呀\nlet methods = [\"push\", \"shift\", \"unshift\", \"pop\", \"reverse\", \"sort\", \"splice\"]\n\n// 下面这个写法非常重要，要注意了\nmethods.forEach((method) => {\n  // arrayMethods 是一个对象 对象的每一个方法都是一个函数\n  // 用户只要使用这7个方法，就会走到自己写的方法中。从而做到了数组劫持\n  // 你看：虽然看似是数组劫持，其实是考察原型链的继承\n  arrayMethods[method] = function (...args) {\n    // 用户传递进来的参数列表 arr.push(1,2,3) ...args = [1,2,3]\n    // 这里我之前一直不是很理解 其实这里 ...args 就是一个整体\n    // 这里的this指向的是谁？ 谁调用就是谁 我们最终会使用 vm.arr.push() pop() 那this就是 数组\n    // 这里数组没有监控索引的变化\n    oldArrayPrototype[method].call(this, ...args)\n\n    let inserted;\n    // 这部分有些绕，绕的地方主要是两个this指的是啥\n    // 这里的this 对应的是当前的数组 __ob__ 属性对应的是Observe实例\n    let ob = this.__ob__; // 这是一个自定义的属性 \n    // 对于数组的新增方法 需要做处理\n    switch (method) {\n      case 'push': // arr.push({a:1},{b:2})\n      case 'unshift': // 这两个方法 都是追加，追加的内容可能是对象类型 应该被再次进行劫持\n        inserted = args // 将args 赋值给这个需要插入的变量\n        break;\n      case 'splice': // vue.$set的原理\n        inserted = args.slice(2); // arr.splice(0,1,{a:1})\n      default:\n        break;\n    }\n\n    if (inserted) {\n      // 为了拿到observe 实例上面的 observeArray 方法 \n      // 先提前将 这个实例绑定到了数组上面\n      inserted = ob.observeArray(inserted); // 给数组新增的值也要进行观测\n    }\n  }\n})\n","import { isObject } from \"../utils\"\nimport { arrayMethods } from \"./array\"\n\n/**\n * vue2会对对象进行遍历，将每个属性 用defineProperty 重新定义 性能差\n * defineReactive 是一个包装 内部就是使用\n * @param {*} data\n * @param {*} key\n * @param {*} value\n */\nfunction defineReactive(data, key, value) {\n  /**\n   * 你看这很显然就是一个递归的操作，发现对象里面嵌套对象\n   * 还是可以进一步的做响应式的处理\n   */\n  observe(value)\n  Object.defineProperty(data, key, {\n    get() {\n      return value\n    },\n    set(newV) {\n      /**\n       * 如果用户赋值一个新的对象 需要将这个对象进行劫持\n       */\n      observe(newV)\n      value = newV\n    },\n  })\n}\n/**\n * 对象没有类型 类有类型 使用类的话入参会在构造函数中被作为参数，接收到\n *\n */\nclass Observer {\n  constructor(data) {\n    // 这里使用defineProperty 定义一个 __ob__ 属性\n    // object.defineProperty 方法会直接在一个对象上定义一个新属性。\n    // 或者修改一个对象的现有属性，并返回此对象。判断一个对象是否被观测过，看它有没有 __ob__ 属性\n    // 注意 使用这个方法定义的属性是不会被枚举的到，不可枚举的好处是不会造成死循环，这里写的真的很好\n    Object.defineProperty(data, \"__ob__\", {\n      enumerable: false,\n      configurable: false,\n      value: this,\n    })\n\n    if (Array.isArray(data)) {\n      // 数组的处理 对数组原来的方法进行改写，这种思路就是面向切面编程\n      // 虽然在最后还是会调用数组原来的方法，但是会在外面包一层函数,\n      // 可以在包装的这层函数中加入自己的一些逻辑——高阶函数\n      // 在学习这部分的内容时候对于原型的理解终究是有些模糊，推荐一篇文章\n      // https://github.com/mqyqingfeng/Blog/issues/2\n      // 文章中有一句话说的特别清晰：每一个JavaScript对象 (null) 除外都拥有__proto__属性 指向它的原型对象\n      data.__proto__ = arrayMethods\n\n      // 这里还需要处理一种情况，如果数组中的元素还是数组，或者数组中的元素是对象，\n      // 我们原则上是需要支持观测内部对象变化的，虽然vue中对于数组没有监控索引的变化\n      // 但是针对数组中元素是对象的情况还是做了处理\n      this.observeArray(data)\n    } else {\n      // 对象的处理\n      this.work(data)\n    }\n  }\n  /**\n   * 观测对象\n   * @param {*} data\n   */\n  observeArray(data) {\n    // 对数组的每一项进行观测。\n    data.forEach((item) => {\n      observe(item)\n    })\n  }\n  /**\n   * data 是一个对象 遍历对象使用object.keys\n   * 这个方法已经很常见了。返回的是一个数组 数组的所有元素\n   * 由这个对象的key组成\n   * 划重点是所有的属性做响应式，哈哈哈，这部分一直迷糊\n   * @param {*} data\n   */\n  work(data) {\n    // console.log(Object.keys(data))  [\"name\", \"showFlag\"]\n    // 这里使用object.keys不会遍历原型上的属性\n    Object.keys(data).forEach((key) => {\n      // 将对象中的每一个「属性」！！！都进行响应式处理\n      defineReactive(data, key, data[key])\n    })\n  }\n}\n\n/**\n * 这个函数接收的是 处理后的data了，还记得在initState中\n * 对data的处理吗，如果判断是函数，就拿到函数的执行结果\n * 并且使用call来绑定this指向防止迷路。\n * @param {*} data\n * @returns\n */\nexport function observe(data) {\n  // 响应式部分是针对对象来说的，如果不是对象直接略过\n  if (!isObject(data)) {\n    return\n  }\n\n  // 这里做一个判断，如果当前的这个数据已经被响应式了\n  // 直接返回就好，不需要重复响应式，最初添加这个属性是在Observer 这个类中做的\n  // 所以被观测的属性，都具有 __ob__ 属性\n  if (data.__ob__) {\n    return data\n  }\n\n  // 这里使用了一个类，之所以没有使用构造函数的原因是\n  // 功能比较耦合,返回的是一个实例\n  return new Observer(data)\n}\n","import { observe } from \"./observer/index.js\"\nimport { isFunction, proxy } from \"./utils\"\n\n/**\n * 初始化数据处理函数 接收的参数是vm实例了\n * 因为很多组件的实例都是需要进行初始数据的\n * @param {*} vm\n */\nexport function initState(vm) {\n  // 还记得在 init.js 中将用户传递的 options 赋值给 vm.$options\n  // 这里可以直接取出来使用了\n  const opts = vm.$options\n  if (opts.props) {\n    initProps(vm)\n  }\n  if (opts.methods) {\n    initMethod(vm)\n  }\n  if (opts.data) {\n    // 初始化data\n    initData(vm)\n  }\n  if (opts.computed) {\n    initComputed(vm)\n  }\n  if (opts.watch) {\n    initWatch(vm)\n  }\n}\n/**\n * 这个函数专门用来处理用户传递进来的data\n * 我们写过vue的都知道，这个data中一般存放的都是页面\n * 中用于显示的响应式数据 比方说一些 tableList 还是一些展示标志位\n * @param {*} vm\n */\nfunction initData(vm) {\n  let data = vm.$options.data\n  // 这里使用 isFunction 工具函数判断传入的data是不是一个函数\n  // 如果是一个函数就执行这个函数，但是执行时候需要绑定vm,因为我们希望在整个执行的过程中\n  // this始终指向vm，也就是当前new出来的实例。\n  // 使用_data 和 data 做一个关联 两者使用同一份引用地址\n  vm._data = data = typeof data === \"function\" ? data.call(vm) : data\n\n  for (let key in data) {\n    proxy(vm, \"_data\", key)\n  }\n\n  // vue2中会将data中的所有数据 进行数据劫持 Object.defineProperty\n  observe(data)\n}\nfunction initProps() {}\nfunction initMethod() {}\nfunction initComputed() {}\nfunction initWatch() {}\n","import { complileToFunction } from \"./compiler/index.js\"\nimport { mountComponent } from \"./lifecycle.js\"\nimport { initState } from \"./state\"\n\n/**\n * 将构造函数作为参数传递进去，对构造函数进行扩展，\n * 这里使用了在构造函数的原型上进行扩展的方式，所有的组件实例均可以共享\n * 表示在vue的基础上做一次混合操作\n * 这种设计思想也是非常值得借鉴的。\n * @param {*} Vue\n */\nexport function initMixin(Vue) {\n  // 扩展原型上的方法\n  Vue.prototype._init = function (options) {\n    // 原型方法中的this指向实例 所有的实例 都具有这些方法\n    // 这里用vm表示this的引用比较方便识别。假设在这个函数中\n    // 直接有一个函数声明，函数声明中的this就不好说是谁了。\n    // 但是可以在函数中使用vm,这个就特别类似于 var that = this 那种写法\n    const vm = this\n    // 用户传递进来的选项挂载到上面,我们能够操作 vm.$options\n    vm.$options = options\n    // 初始化状态 为什么要有这个 函数 不仅仅是 有watch\n    // 还有computed props data 我们需要有一个统一的函数\n    // 来处理这些参数。\n    initState(vm)\n    // 数据初始化就这样结束了吗？ 当然没有 我们还需要将数据挂载到模板上面\n    if (vm.$options.el) {\n      // 将数据挂载到模板上\n      vm.$mount(vm.$options.el)\n    }\n  }\n  /**\n   * 这个就是那个渲染的方法\n   * 我们说，如果每次数据变化，就全部将模板替换，这种方式是很低效的\n   * 因为vue2 中将模板转换成渲染函数，函数的执行效率要高很多。\n   * 并且引入了虚拟dom的概念，每次数据变化，生成虚拟节点。而不是真正的操作dom\n   * @param {*} el\n   */\n  Vue.prototype.$mount = function (el) {\n    const vm = this\n    const options = vm.$options\n    el = document.querySelector(el)\n    // 这里解释下为什么要做这个判断，因为会有情况是用户手动写render方法\n    // 这种情况下用户手写的render优先级要更高一些。这个函数的终极目标是帮助我们\n    // 创建出虚拟节点\n    // 这部分信息量比较大，我们可以在options的选项中添加 template 字段\n    // 如果没写，才使用 html中写的dom节点，这点应该尤其注意\n    if (!options.render) {\n      let template = options.template\n      if (!template) {\n        template = el.outerHTML\n        // 下面这一行打印的是字符串\n        // console.log(template) <div id=\"app\">{{name}}</div>\n        // 这个函数是一个核心的函数，将我们传递进去的模板编译成 render函数\n        let render = complileToFunction(template)\n        options.render = render\n      }\n    }\n    // 调用render方法 渲染成真实的dom替换掉页面的内容\n    // 这个方法是定义在生命周期这个包中的\n    mountComponent(vm, el)\n  }\n}\n","export function renderMixin(Vue) {\n  Vue.prototype._render = function () {\n    const vm = this;\n    let render = vm.$options.render; // 这个render 就是我们解析出来的render方法 同时也有可能是用户自己写的render\n    \n    let vnode = render.call(vm);\n\n    return vnode\n  }\n}\n","import { initMixin } from \"./init\"\nimport { lifecycleMixin } from \"./lifecycle\";\nimport { renderMixin } from \"./render\";\n\n/**\n * 接收一个option作为参数 是一个对象\n * 这个options就是用户传递进来的配置选项\n * 这个配置选项中包含 data el watch computed methods。。。\n * 一些列的参数，在使用vue-cli脚手架进行开发的时候\n * 都是单组件文件 每个组件本质上都是一个实例\n * @param {*} options \n */\nfunction Vue(options) {\n  // options 为用户传入的选项\n  this._init(options) // 初始化操作\n}\n\n// 只要加载了index.js 这个文件下面的函数都会执行\n// 并且是首先执行的，那么所有在mixin上挂载的所有原型\n// 方法都会预先定义执行，init 是在new 的时候执行的\ninitMixin(Vue);\nrenderMixin(Vue);  // 存放的是 _render\nlifecycleMixin(Vue); // 存放的是 _update\n\n// 将vue导出\nexport default Vue\n"],"names":["defaultTagRE","genProps","attrs","str","i","length","attr","name","obj","value","split","forEach","item","key","JSON","stringify","slice","gen","node","type","generate","text","test","tokens","lastIndex","match","index","exec","push","trim","join","genChildren","el","children","map","child","code","tag","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","createASTElement","tagName","parent","root","currentParent","stack","start","element","end","pop","chars","replace","advance","n","substring","parseStartTag","textend","indexOf","startTagMatch","endTagMatch","complileToFunction","template","ast","render","Function","lifecycleMixin","Vue","prototype","_update","vnode","console","log","mountComponent","vm","updateComponent","_render","proxy","data","Object","defineProperty","get","set","newVal","isObject","val","oldArrayPrototype","Array","arrayMethods","create","methods","method","args","call","inserted","ob","__ob__","observeArray","defineReactive","observe","newV","Observer","enumerable","configurable","isArray","__proto__","work","keys","initState","opts","$options","props","initData","computed","watch","_data","initMixin","_init","options","$mount","document","querySelector","outerHTML","renderMixin"],"mappings":"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"}